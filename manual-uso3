Manual de Uso: Asistente de Cultivos (v15.1)
El Asistente de Cultivos es una aplicaci√≥n de escritorio dise√±ada para gestionar, planificar y analizar tus proyectos agr√≠colas, combinando la gesti√≥n de datos con capacidades financieras y de an√°lisis avanzado.

1. ‚öôÔ∏è Requisitos y Ejecuci√≥n
Tarea	Instrucci√≥n
Archivos Necesarios	cultivos.py (c√≥digo), ventas_mensuales.csv (datos de an√°lisis), cultivos.json (datos guardados autom√°ticamente). Deben estar en la misma carpeta.
Librer√≠as	Necesitas tener instaladas: tkinter (incluido en Python), pandas, matplotlib, y tkcalendar.
Ejecuci√≥n	Abre la terminal/PowerShell en la carpeta del proyecto y ejecuta: python cultivos.py

Exportar a Hojas de c√°lculo

2. üìù Panel Izquierdo: A√±adir/Editar Cultivo
Este panel se utiliza para ingresar y modificar la informaci√≥n detallada de cada proyecto de cultivo.

Secci√≥n	Funcionalidad
Nombre	Nombre del cultivo (ej: "Tomate Cherry").
Zona	Permite clasificar el cultivo por ubicaci√≥n (ej: "Invernadero", "Zona A").
Fechas	Usa los botones "Elegir Fecha..." para seleccionar la fecha de Siembra y Cosecha con un calendario interactivo.
Costo (‚Ç¨)	El precio o costo asociado con la compra de semillas, tierra, etc.
Venta Est. (‚Ç¨)	El precio de venta estimado o el ingreso potencial que esperas obtener.
Notas	Campo opcional para informaci√≥n adicional sobre cuidados, plagas, etc.
Botones	"A√±adir a la Lista" / "Guardar Cambios": Guarda el nuevo cultivo o aplica modificaciones al seleccionado. "Limpiar Campos": Borra el contenido de los formularios.

Exportar a Hojas de c√°lculo

3. üìä Panel Derecho: Gesti√≥n y Reportes
Este panel muestra un resumen de todos tus cultivos y contiene las herramientas de reporte y an√°lisis.

A. Resumen Financiero Potencial
Muestra una suma r√°pida de la salud financiera de todos tus cultivos activos:

Costo Total: Suma de todos los costos de compra.

Venta Est. Total: Suma de todas las ventas estimadas.

Margen Potencial: La diferencia entre la venta total y el costo total.

B. Lista de Cultivos (Treeview)
Muestra todos los cultivos en formato de tabla, destacando informaci√≥n clave:

Columna	Descripci√≥n	Indicador Visual
Cultivo / Zona	El nombre y la ubicaci√≥n de tu proyecto.	
Siembra / Cosecha	Las fechas clave.	
Costo / Venta / Margen	Los valores financieros individuales.	
Faltan	Muestra los d√≠as restantes hasta la cosecha.	Verde: Faltan d√≠as. Amarillo/Negro: ¬°Cosecha Hoy! Gris: Ya Cosechado.

Exportar a Hojas de c√°lculo

C. Botones de Gesti√≥n y An√°lisis
Bot√≥n	Funcionalidad	M√≥dulo(s) Clave
‚úèÔ∏è Editar Seleccionado	Carga la informaci√≥n del cultivo seleccionado en el panel izquierdo para su edici√≥n.	Tkinter
‚ùå Eliminar	Elimina permanentemente el cultivo seleccionado tras pedir confirmaci√≥n.	Tkinter
üì§ Exportar Cultivos CSV	Exporta todos los datos de tus cultivos a un archivo CSV con delimitador ; (punto y coma).	CSV, Tkinter
üìà Analizar Ventas Externas	¬°NUEVA FUNCI√ìN! Carga y procesa el archivo ventas_mensuales.csv para generar an√°lisis detallados.	Pandas, Matplotlib

Exportar a Hojas de c√°lculo

4. üìà Funcionalidad de An√°lisis Avanzado
Al hacer clic en "Analizar Ventas Externas", la aplicaci√≥n:

Valida el archivo: Verifica que ventas_mensuales.csv exista.

Calcula M√©tricas: Imprime en la consola las ventas totales, promedio, m√°xima y m√≠nima.

Muestra Gr√°ficos: Abre una ventana flotante con dos visualizaciones lado a lado:

Gr√°fico 1 (Barras): Muestra las Ventas Totales por Tipo de Producto para identificar los productos m√°s vendidos.

Gr√°fico 2 (L√≠neas): Muestra la Tendencia de Ventas a lo Largo del Tiempo (por Mes) para identificar estacionalidad o crecimiento.

Siguiente paso: ¬øTe gustar√≠a que implementemos el An√°lisis de Ventas por Regi√≥n para completar el an√°lisis de los datos externos, o tienes alguna otra consulta sobre c√≥mo usar las funciones existentes?


analisis de ventas por region:
Asistente de programaci√≥n
¬°Qu√© fant√°stico plan! Tienes cuatro objetivos muy potentes que llevar√°n tu aplicaci√≥n a un nivel superior.

Para mantener un enfoque claro y garantizar la correcta implementaci√≥n, te sugiero que abordemos estos puntos uno por uno.

Propongo comenzar con el An√°lisis por Regi√≥n, ya que es una extensi√≥n directa del c√≥digo de an√°lisis de datos que acabamos de integrar.

üéØ Nuevo Objetivo: An√°lisis de Ventas por Regi√≥n
Vamos a modificar la funci√≥n analizar_ventas_externas para:

Agrupar las ventas por la columna 'Region' (Norte, Sur, Centro).

Generar un tercer gr√°fico de barras que compare las ventas totales de cada regi√≥n.

Mostrar los tres gr√°ficos (Producto, Temporal, y Regi√≥n) en la misma ventana de Matplotlib usando subplots (tres gr√°ficos en una sola figura).

üìù Modificaci√≥n en cultivos.py (An√°lisis por Regi√≥n)
Por favor, reemplaza el m√©todo analizar_ventas_externas completo en tu clase AppCultivos por el siguiente c√≥digo.

Asistente de programaci√≥n
¬°Qu√© fant√°stico plan! Tienes cuatro objetivos muy potentes que llevar√°n tu aplicaci√≥n a un nivel superior.

Para mantener un enfoque claro y garantizar la correcta implementaci√≥n, te sugiero que abordemos estos puntos uno por uno.

Propongo comenzar con el An√°lisis por Regi√≥n, ya que es una extensi√≥n directa del c√≥digo de an√°lisis de datos que acabamos de integrar.

üéØ Nuevo Objetivo: An√°lisis de Ventas por Regi√≥n
Vamos a modificar la funci√≥n analizar_ventas_externas para:

Agrupar las ventas por la columna 'Region' (Norte, Sur, Centro).

Generar un tercer gr√°fico de barras que compare las ventas totales de cada regi√≥n.

Mostrar los tres gr√°ficos (Producto, Temporal, y Regi√≥n) en la misma ventana de Matplotlib usando subplots (tres gr√°ficos en una sola figura).

üìù Modificaci√≥n en cultivos.py (An√°lisis por Regi√≥n)
Por favor, reemplaza el m√©todo analizar_ventas_externas completo en tu clase AppCultivos por el siguiente c√≥digo.

He ajustado la estructura de Matplotlib para manejar tres subplots en una configuraci√≥n de 1√ó3 (una fila, tres columnas).

def analizar_ventas_externas(self):
        """
        Carga el archivo CSV externo, calcula m√©tricas financieras, y genera tres gr√°ficos:
        Ventas por Producto, Tendencia Temporal, y Ventas por Regi√≥n.
        """
        nombre_archivo = NOMBRE_ARCHIVO_VENTAS
        
        # 1. Carga de Datos y Manejo de Errores
        if not os.path.exists(nombre_archivo):
            messagebox.showwarning("Advertencia", 
                                   f"No se encontr√≥ el archivo de ventas externas '{nombre_archivo}'.\n"
                                   f"Aseg√∫rate de que exista y se llame '{NOMBRE_ARCHIVO_VENTAS}'.")
            return

        try:
            df = pd.read_csv(nombre_archivo, sep=',')
        except pd.errors.ParserError:
            messagebox.showerror("Error", "Error de formato en el CSV. ¬øEs el delimitador correcto (coma)?")
            return
        except Exception as e:
            messagebox.showerror("Error", f"Error inesperado al cargar los datos: {e}")
            return

        # 2. Preparaci√≥n de Datos
        df['Venta_Total'] = pd.to_numeric(df['Venta_Total'], errors='coerce')
        df.dropna(subset=['Venta_Total'], inplace=True)
        
        if df.empty:
            messagebox.showwarning("Advertencia", "El archivo de ventas est√° vac√≠o o solo contiene encabezados v√°lidos.")
            return

        # 3. An√°lisis Agrupado (Ventas por Producto)
        ventas_por_producto = df.groupby('Producto')['Venta_Total'].sum().sort_values(ascending=False)
        
        # 4. An√°lisis Agrupado Temporal (Ventas por Mes)
        mapa_meses = {'Ene': 1, 'Feb': 2, 'Mar': 3, 'Abr': 4, 'May': 5, 'Jun': 6, 
                      'Jul': 7, 'Ago': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dic': 12}
        df['Num_Mes'] = df['Mes'].map(mapa_meses)
        ventas_por_mes = df.groupby(['Num_Mes', 'Mes'])['Venta_Total'].sum().reset_index(level=1).sort_values(by='Num_Mes')
        
        
        # --- NUEVO: 5. An√°lisis Agrupado por Regi√≥n ---
        ventas_por_region = df.groupby('Region')['Venta_Total'].sum().sort_values(ascending=False)
        
        print("\n--- REPORTE DE VENTAS POR REGI√ìN ---")
        print(ventas_por_region.to_string())

        
        # --- 6. VISUALIZACI√ìN DE DATOS con Matplotlib (Tres Subplots) ---
        try:
            plt.style.use('dark_background') 
            # Creamos una figura con una fila y tres columnas para los gr√°ficos
            fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))
            fig.suptitle('An√°lisis Detallado de Ventas Externas (Producto, Temporal y Regi√≥n)', color='white', fontsize=16)

            
            # --- Gr√°fico 1: Ventas por Producto (Barras) ---
            ventas_por_producto.plot(kind='bar', color='#1E8449', ax=ax1) 
            ax1.set_title('1. Ventas por Producto', color='white')
            ax1.set_xlabel('Producto', color='white')
            ax1.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax1.tick_params(axis='x', rotation=45, colors='white')
            ax1.tick_params(axis='y', colors='white')
            ax1.grid(axis='y', linestyle='--', alpha=0.4) 
            
            # --- Gr√°fico 2: Ventas por Mes (L√≠neas) ---
            ax2.plot(ventas_por_mes['Mes'], ventas_por_mes['Venta_Total'], 
                     marker='o', linestyle='-', color='#007BFF', linewidth=3)
            ax2.set_title('2. Tendencia Temporal (Mes)', color='white')
            ax2.set_xlabel('Mes', color='white')
            ax2.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax2.tick_params(axis='x', rotation=0, colors='white')
            ax2.tick_params(axis='y', colors='white')
            ax2.grid(axis='both', linestyle='--', alpha=0.4) 
            
            # --- Gr√°fico 3: Ventas por Regi√≥n (Barras) ---
            ventas_por_region.plot(kind='bar', color='#FFC107', ax=ax3) 
            ax3.set_title('3. Ventas por Regi√≥n', color='white')
            ax3.set_xlabel('Regi√≥n', color='white')
            ax3.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax3.tick_params(axis='x', rotation=45, colors='white')
            ax3.tick_params(axis='y', colors='white')
            ax3.grid(axis='y', linestyle='--', alpha=0.4) 

            
            plt.tight_layout(rect=[0, 0.03, 1, 0.95]) 
            messagebox.showinfo("An√°lisis Completo", "Se han generado TRES gr√°ficos de an√°lisis: Producto, Temporal y Regi√≥n.")
            plt.show() 

        except Exception as e:
            messagebox.showerror("Error de Gr√°fico", f"No se pudo generar el gr√°fico: {e}")

Pr√≥ximo Paso
Una vez que reemplaces el c√≥digo y ejecutes la aplicaci√≥n, el bot√≥n "üìà Analizar Ventas Externas" te mostrar√° el reporte completo con los tres enfoques de an√°lisis.

¬øNecesitas el c√≥digo completo de cultivos.py con esta √∫ltima modificaci√≥n, o prefieres pasar directamente a la Predicci√≥n Simple (proyectar ventas futuras)?

A√±adir la Predicci√≥n Simple a tu an√°lisis es un gran salto hacia la inteligencia de datos en tu aplicaci√≥n. Utilizaremos la Regresi√≥n Lineal para proyectar las tendencias futuras.

Para esto, necesitamos introducir una nueva librer√≠a de Python que simplifica la creaci√≥n de modelos de regresi√≥n: scikit-learn (o sklearn).

Requisito Adicional
Si a√∫n no lo tienes instalado, abre tu terminal y ejecuta:
pip install scikit-learn

Modificaci√≥n en cultivos.py (Predicci√≥n Simple)
Vamos a actualizar el m√©todo analizar_ventas_externas en dos pasos:

Nuevo Import: A√±adiremos la clase LinearRegression de sklearn.

Nueva L√≥gica de Predicci√≥n: Entrenaremos el modelo con ventas_por_mes y haremos una predicci√≥n para el siguiente mes.

Visualizaci√≥n: A√±adiremos la l√≠nea de predicci√≥n al gr√°fico de Tendencia Temporal.

Reemplaza la versi√≥n actual de analizar_ventas_externas en tu archivo cultivos.py por el siguiente c√≥digo.

1. Nuevos Imports Necesarios
Aseg√∫rate de que tus imports al inicio de cultivos.py incluyan:

# ... (otros imports)
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression # <--- NUEVO IMPORT
import numpy as np # <--- NUEVO IMPORT para manejar arrays

2. C√≥digo del M√©todo analizar_ventas_externas (con Predicci√≥n)
Aqu√≠ est√° el m√©todo completo. Presta especial atenci√≥n a la nueva Secci√≥n 6. Predicci√≥n de Ventas (Regresi√≥n Lineal) y c√≥mo actualiza el Gr√°fico 2.


def analizar_ventas_externas(self):
        """
        Carga el archivo CSV externo, realiza an√°lisis descriptivo, y genera 
        tres gr√°ficos: Producto, Tendencia Temporal (con Predicci√≥n), y Regi√≥n.
        """
        nombre_archivo = NOMBRE_ARCHIVO_VENTAS
        
        # 1. Carga de Datos y Manejo de Errores (Sin cambios)
        if not os.path.exists(nombre_archivo):
            # ... (manejo de error)
            messagebox.showwarning("Advertencia", 
                                   f"No se encontr√≥ el archivo de ventas externas '{nombre_archivo}'.\n"
                                   f"Aseg√∫rate de que exista y se llame '{NOMBRE_ARCHIVO_VENTAS}'.")
            return
        try:
            df = pd.read_csv(nombre_archivo, sep=',')
        except Exception as e:
            # ... (manejo de error)
            messagebox.showerror("Error", f"Error al cargar/formato de datos: {e}")
            return

        # 2. Preparaci√≥n de Datos (Sin cambios)
        df['Venta_Total'] = pd.to_numeric(df['Venta_Total'], errors='coerce')
        df.dropna(subset=['Venta_Total'], inplace=True)
        if df.empty:
            messagebox.showwarning("Advertencia", "El archivo de ventas est√° vac√≠o o solo contiene encabezados v√°lidos.")
            return

        # 3. An√°lisis por Producto (Sin cambios)
        ventas_por_producto = df.groupby('Producto')['Venta_Total'].sum().sort_values(ascending=False)
        
        # 4. An√°lisis Temporal (Preparaci√≥n para Regresi√≥n)
        mapa_meses = {'Ene': 1, 'Feb': 2, 'Mar': 3, 'Abr': 4, 'May': 5, 'Jun': 6, 
                      'Jul': 7, 'Ago': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dic': 12}
        df['Num_Mes'] = df['Mes'].map(mapa_meses)
        ventas_por_mes_df = df.groupby(['Num_Mes', 'Mes'])['Venta_Total'].sum().reset_index()
        ventas_por_mes_df = ventas_por_mes_df.sort_values(by='Num_Mes').reset_index(drop=True)
        
        # 5. An√°lisis por Regi√≥n (Sin cambios)
        ventas_por_region = df.groupby('Region')['Venta_Total'].sum().sort_values(ascending=False)
        
        
        # --- NUEVO: 6. PREDICCI√ìN DE VENTAS (REGRESI√ìN LINEAL) ---
        
        # Preparamos los datos para el modelo X (Meses) y Y (Ventas)
        X = ventas_por_mes_df['Num_Mes'].values.reshape(-1, 1) 
        Y = ventas_por_mes_df['Venta_Total'].values
        
        # Creamos y entrenamos el modelo
        modelo_regresion = LinearRegression()
        modelo_regresion.fit(X, Y)
        
        # Hacemos una predicci√≥n para el siguiente mes
        ultimo_mes_num = ventas_por_mes_df['Num_Mes'].max()
        mes_futuro_num = ultimo_mes_num + 1
        
        # Calculamos el nombre del mes futuro para la visualizaci√≥n (Ej: Abr -> May)
        meses_lista = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic']
        mes_futuro_nombre = meses_lista[mes_futuro_num - 1] if mes_futuro_num <= 12 else f"Mes {mes_futuro_num}"

        # Predecimos la venta para ese mes
        prediccion_futura = modelo_regresion.predict(np.array([[mes_futuro_num]]))[0]
        
        print("\n--- PREDICCI√ìN DE VENTAS ---")
        print(f"Predicci√≥n de venta para {mes_futuro_nombre}: ‚Ç¨{prediccion_futura:.2f}")

        # A√±adimos la predicci√≥n al DataFrame temporal para el gr√°fico
        X_pred = np.append(X, [[mes_futuro_num]], axis=0) # Incluimos el mes futuro
        Y_tendencia = modelo_regresion.predict(X_pred)     # Calculamos toda la l√≠nea de tendencia
        
        # Preparamos las etiquetas del eje X para el gr√°fico
        labels_x = ventas_por_mes_df['Mes'].tolist() + [f"Pred. {mes_futuro_nombre}"]
        
        
        # --- 7. VISUALIZACI√ìN DE DATOS con Matplotlib (Tres Subplots) ---
        try:
            plt.style.use('dark_background') 
            fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))
            fig.suptitle(f'An√°lisis de Ventas (Predicci√≥n {mes_futuro_nombre}: ‚Ç¨{prediccion_futura:.2f})', color='white', fontsize=16)

            
            # --- Gr√°fico 1: Ventas por Producto (Barras) ---
            ventas_por_producto.plot(kind='bar', color='#1E8449', ax=ax1) 
            ax1.set_title('1. Ventas por Producto', color='white')
            # ... (configuraci√≥n de ejes, sin cambios)
            ax1.set_xlabel('Producto', color='white')
            ax1.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax1.tick_params(axis='x', rotation=45, colors='white')
            ax1.tick_params(axis='y', colors='white')
            ax1.grid(axis='y', linestyle='--', alpha=0.4) 
            
            # --- Gr√°fico 2: Ventas por Mes (L√≠neas con Predicci√≥n) ---
            # Datos Hist√≥ricos
            ax2.plot(ventas_por_mes_df['Mes'], ventas_por_mes_df['Venta_Total'], 
                     marker='o', linestyle='-', color='#007BFF', linewidth=3, label='Ventas Hist√≥ricas')
            # L√≠nea de Tendencia y Predicci√≥n
            ax2.plot(labels_x, Y_tendencia, 
                     linestyle='--', color='#FFC107', linewidth=2, label='Predicci√≥n Lineal')
                     
            ax2.set_title('2. Tendencia Temporal y Predicci√≥n', color='white')
            ax2.set_xlabel('Mes', color='white')
            ax2.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax2.tick_params(axis='x', rotation=45, colors='white')
            ax2.tick_params(axis='y', colors='white')
            ax2.grid(axis='both', linestyle='--', alpha=0.4) 
            ax2.legend(loc='upper left', frameon=False) 
            
            # --- Gr√°fico 3: Ventas por Regi√≥n (Barras) ---
            ventas_por_region.plot(kind='bar', color='#FFC107', ax=ax3) 
            ax3.set_title('3. Ventas por Regi√≥n', color='white')
            # ... (configuraci√≥n de ejes, sin cambios)
            ax3.set_xlabel('Regi√≥n', color='white')
            ax3.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax3.tick_params(axis='x', rotation=45, colors='white')
            ax3.tick_params(axis='y', colors='white')
            ax3.grid(axis='y', linestyle='--', alpha=0.4) 

            
            plt.tight_layout(rect=[0, 0.03, 1, 0.95]) 
            messagebox.showinfo("An√°lisis Completo", f"Se han generado tres gr√°ficos, incluyendo una predicci√≥n para {mes_futuro_nombre}.")
            plt.show() 

        except Exception as e:
            messagebox.showerror("Error de Gr√°fico/Predicci√≥n", f"No se pudo generar el gr√°fico o el modelo: {e}")

Pasos para la Implementaci√≥n
Instala Scikit-learn: pip install scikit-learn.

Actualiza Imports: Aseg√∫rate de que el inicio de tu cultivos.py tenga:

# ...
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression 
import numpy as np 
# ...


Reemplaza el M√©todo: Copia el nuevo m√©todo analizar_ventas_externas y reemplaza la versi√≥n anterior en tu cultivos.py.

Una vez que lo ejecutes y presiones "üìà Analizar Ventas Externas", ver√°s una l√≠nea de tendencia en el segundo gr√°fico que se extiende al siguiente mes con la predicci√≥n.

Ahora que tenemos la Predicci√≥n Simple lista, ¬øpasamos a las Alarmas Inteligentes para configurar alertas basadas en el ciclo de vida de los cultivos?

Asistente de programaci√≥n
¬°Fant√°stico! Las Alarmas Inteligentes son un paso crucial para pasar de ser un simple gestor a un verdadero asistente proactivo.

El objetivo es que, para cada tipo de cultivo, podamos definir:

D√≠as de Alerta Temprana: ¬øCon cu√°ntos d√≠as de antelaci√≥n queremos que se active una alarma antes de la fecha de cosecha (ej: 7 d√≠as para preparar el equipo)?

Ciclo de Vida (Opcional): Una referencia de cu√°ntos d√≠as dura normalmente ese cultivo (ej: El tomate suele tardar 90 d√≠as).

Como no tenemos un campo para el "tipo" de cultivo ni para la "alerta", te propongo que hagamos lo siguiente:

Plan de Implementaci√≥n de Alarmas Inteligentes
Modificar el Modelo Cultivo: A√±adiremos un nuevo campo llamado dias_alerta al modelo Cultivo.

Modificar la Interfaz: A√±adiremos una nueva caja de entrada en el panel izquierdo para que el usuario pueda ingresar los "D√≠as de Alerta Previa".

Nueva L√≥gica de Alarma: Crearemos una nueva funci√≥n que no solo revisa la cosecha de hoy, sino que tambi√©n verifica si alg√∫n cultivo est√° dentro del rango de d√≠as de alerta que ha especificado el usuario.

Asistente de programaci√≥n
¬°Fant√°stico! Las Alarmas Inteligentes son un paso crucial para pasar de ser un simple gestor a un verdadero asistente proactivo.
Imagen de an alarm clock
Shutterstock

El objetivo es que, para cada tipo de cultivo, podamos definir:

D√≠as de Alerta Temprana: ¬øCon cu√°ntos d√≠as de antelaci√≥n queremos que se active una alarma antes de la fecha de cosecha (ej: 7 d√≠as para preparar el equipo)?

Ciclo de Vida (Opcional): Una referencia de cu√°ntos d√≠as dura normalmente ese cultivo (ej: El tomate suele tardar 90 d√≠as).

Como no tenemos un campo para el "tipo" de cultivo ni para la "alerta", te propongo que hagamos lo siguiente:

üìù Plan de Implementaci√≥n de Alarmas Inteligentes
Modificar el Modelo Cultivo: A√±adiremos un nuevo campo llamado dias_alerta al modelo Cultivo.

Modificar la Interfaz: A√±adiremos una nueva caja de entrada en el panel izquierdo para que el usuario pueda ingresar los "D√≠as de Alerta Previa".

Nueva L√≥gica de Alarma: Crearemos una nueva funci√≥n que no solo revisa la cosecha de hoy, sino que tambi√©n verifica si alg√∫n cultivo est√° dentro del rango de d√≠as de alerta que ha especificado el usuario.

1. Modificaci√≥n en cultivos.py (Modelo, Funciones y Widgets)
Aqu√≠ tienes las secciones de c√≥digo que debes actualizar en tu archivo cultivos.py.

A. Actualizar el modelo Cultivo
Busca la clase Cultivo (cerca de la l√≠nea 32) y a√±ade dias_alerta=0 a __init__:
# --- 1. CLASE MODELO (LA L√ìGICA DE NEGOCIO) ---
class Cultivo:
    """Clase base para guardar la informaci√≥n de un cultivo..."""
    # Nuevo par√°metro: dias_alerta
    def __init__(self, nombre, fecha_siembra, fecha_cosecha, notas="", zona="", precio_compra=0.0, precio_venta=0.0, dias_alerta=0):
        self.nombre = nombre
        self.fecha_siembra = fecha_siembra
        self.fecha_cosecha = fecha_cosecha
        self.notas = notas
        self.zona = zona 
        self.precio_compra = precio_compra 
        self.precio_venta = precio_venta 
        self.dias_alerta = dias_alerta # <- NUEVO CAMPO

B. Actualizar cargar_cultivos y guardar_cultivos
Necesitamos asegurarnos de que el nuevo campo se carga y se guarda correctamente en el JSON.

En cargar_cultivos (cerca de la l√≠nea 60):

# En la funci√≥n 'cargar_cultivos'
# ...
            for item in datos_cargados:
                # ... (resto de variables)
                precio_venta = float(item.get("precio_venta", 0.0))
                dias_alerta = int(item.get("dias_alerta", 0)) # <- NUEVO CAMPO
                
                if siembra and cosecha:
                    # Pasar el nuevo argumento al constructor:
                    nuevo = Cultivo(item["nombre"], siembra, cosecha, notas, zona, precio_compra, precio_venta, dias_alerta)
                    lista_cultivos.append(nuevo)
# ...

En guardar_cultivos (cerca de la l√≠nea 85):
# En la funci√≥n 'guardar_cultivos'
# ...
        for cultivo in lista_cultivos:
            cultivo_dict = {
                "nombre": cultivo.nombre,
                # ... (resto de campos)
                "precio_compra": cultivo.precio_compra,
                "precio_venta": cultivo.precio_venta,
                "dias_alerta": cultivo.dias_alerta # <- NUEVO CAMPO
            }
            datos_para_json.append(cultivo_dict)
# ...

C. Crear el Widget de D√≠as de Alerta
Busca el m√©todo crear_widgets (cerca de la l√≠nea 157) y a√±ade el siguiente c√≥digo en el Marco Izquierdo (antes del bot√≥n self.btn_guardar).

# ... (dentro de self.crear_widgets, justo antes del bot√≥n self.btn_guardar)

        self.dias_alerta_var = tk.StringVar(value="7") # Valor por defecto
        
        frame_alerta = ttk.LabelFrame(frame_agregar, text="üîî Alarma Inteligente", padding="5")
        frame_alerta.pack(fill='x', pady=5)
        
        ttk.Label(frame_alerta, text="D√≠as de Alerta Previa a Cosecha:").pack(fill='x', pady=2)
        ttk.Entry(frame_alerta, textvariable=self.dias_alerta_var).pack(fill='x', pady=1)

# ... (El resto de la funci√≥n crear_widgets sigue igual)

Asistente de programaci√≥n
¬°Fant√°stico! Las Alarmas Inteligentes son un paso crucial para pasar de ser un simple gestor a un verdadero asistente proactivo.
Imagen de an alarm clock
Shutterstock

El objetivo es que, para cada tipo de cultivo, podamos definir:

D√≠as de Alerta Temprana: ¬øCon cu√°ntos d√≠as de antelaci√≥n queremos que se active una alarma antes de la fecha de cosecha (ej: 7 d√≠as para preparar el equipo)?

Ciclo de Vida (Opcional): Una referencia de cu√°ntos d√≠as dura normalmente ese cultivo (ej: El tomate suele tardar 90 d√≠as).

Como no tenemos un campo para el "tipo" de cultivo ni para la "alerta", te propongo que hagamos lo siguiente:

üìù Plan de Implementaci√≥n de Alarmas Inteligentes
Modificar el Modelo Cultivo: A√±adiremos un nuevo campo llamado dias_alerta al modelo Cultivo.

Modificar la Interfaz: A√±adiremos una nueva caja de entrada en el panel izquierdo para que el usuario pueda ingresar los "D√≠as de Alerta Previa".

Nueva L√≥gica de Alarma: Crearemos una nueva funci√≥n que no solo revisa la cosecha de hoy, sino que tambi√©n verifica si alg√∫n cultivo est√° dentro del rango de d√≠as de alerta que ha especificado el usuario.

1. Modificaci√≥n en cultivos.py (Modelo, Funciones y Widgets)
Aqu√≠ tienes las secciones de c√≥digo que debes actualizar en tu archivo cultivos.py.

A. Actualizar el modelo Cultivo
Busca la clase Cultivo (cerca de la l√≠nea 32) y a√±ade dias_alerta=0 a __init__:

Python
# --- 1. CLASE MODELO (LA L√ìGICA DE NEGOCIO) ---
class Cultivo:
    """Clase base para guardar la informaci√≥n de un cultivo..."""
    # Nuevo par√°metro: dias_alerta
    def __init__(self, nombre, fecha_siembra, fecha_cosecha, notas="", zona="", precio_compra=0.0, precio_venta=0.0, dias_alerta=0):
        self.nombre = nombre
        self.fecha_siembra = fecha_siembra
        self.fecha_cosecha = fecha_cosecha
        self.notas = notas
        self.zona = zona 
        self.precio_compra = precio_compra 
        self.precio_venta = precio_venta 
        self.dias_alerta = dias_alerta # <- NUEVO CAMPO
B. Actualizar cargar_cultivos y guardar_cultivos
Necesitamos asegurarnos de que el nuevo campo se carga y se guarda correctamente en el JSON.

En cargar_cultivos (cerca de la l√≠nea 60):

Python
# En la funci√≥n 'cargar_cultivos'
# ...
            for item in datos_cargados:
                # ... (resto de variables)
                precio_venta = float(item.get("precio_venta", 0.0))
                dias_alerta = int(item.get("dias_alerta", 0)) # <- NUEVO CAMPO
                
                if siembra and cosecha:
                    # Pasar el nuevo argumento al constructor:
                    nuevo = Cultivo(item["nombre"], siembra, cosecha, notas, zona, precio_compra, precio_venta, dias_alerta)
                    lista_cultivos.append(nuevo)
# ...
En guardar_cultivos (cerca de la l√≠nea 85):

Python
# En la funci√≥n 'guardar_cultivos'
# ...
        for cultivo in lista_cultivos:
            cultivo_dict = {
                "nombre": cultivo.nombre,
                # ... (resto de campos)
                "precio_compra": cultivo.precio_compra,
                "precio_venta": cultivo.precio_venta,
                "dias_alerta": cultivo.dias_alerta # <- NUEVO CAMPO
            }
            datos_para_json.append(cultivo_dict)
# ...
C. Crear el Widget de D√≠as de Alerta
Busca el m√©todo crear_widgets (cerca de la l√≠nea 157) y a√±ade el siguiente c√≥digo en el Marco Izquierdo (antes del bot√≥n self.btn_guardar).

Python
# ... (dentro de self.crear_widgets, justo antes del bot√≥n self.btn_guardar)

        self.dias_alerta_var = tk.StringVar(value="7") # Valor por defecto
        
        frame_alerta = ttk.LabelFrame(frame_agregar, text="üîî Alarma Inteligente", padding="5")
        frame_alerta.pack(fill='x', pady=5)
        
        ttk.Label(frame_alerta, text="D√≠as de Alerta Previa a Cosecha:").pack(fill='x', pady=2)
        ttk.Entry(frame_alerta, textvariable=self.dias_alerta_var).pack(fill='x', pady=1)

# ... (El resto de la funci√≥n crear_widgets sigue igual)
D. Actualizar manejar_agregar_o_editar
Necesitamos leer el valor del nuevo campo y guardarlo en el objeto Cultivo.

Busca la funci√≥n manejar_agregar_o_editar (cerca de la l√≠nea 274).

Validaci√≥n de dias_alerta: A√±ade esta validaci√≥n al inicio:

# ... (Despu√©s de validar nombre, fechas y precios)
    try:
        precio_compra = float(self.compra_var.get().strip() or 0.0)
        precio_venta = float(self.venta_var.get().strip() or 0.0)

        # --- NUEVA VALIDACI√ìN ---
        dias_alerta = int(self.dias_alerta_var.get().strip() or 0)
        if dias_alerta < 0:
            raise ValueError("La alarma no puede tener d√≠as negativos.")
        # ------------------------

    except ValueError as e:
        messagebox.showerror("Error", f"Los d√≠as de alerta deben ser un n√∫mero entero positivo. {e}")
        return
# ...
Guardar el valor: En la creaci√≥n (modo a√±adir):
# ... (Dentro de if self.cultivo_seleccionado_indice is None:)
    if self.cultivo_seleccionado_indice is None:
        # Pasar el nuevo par√°metro 'dias_alerta'
        nuevo_cultivo = Cultivo(nombre, fecha_siembra, fecha_cosecha, notas, zona, precio_compra, precio_venta, dias_alerta)
        lista_cultivos.append(nuevo_cultivo)
        msg = f"'{nombre}' a√±adido con √©xito."
# ...

Actualizar el valor: En la edici√≥n:

# ... (Dentro de else: (modo editar))
    else:
        indice = self.cultivo_seleccionado_indice
        cultivo_a_editar = lista_cultivos[indice]
        # ... (resto de campos)
        cultivo_a_editar.precio_compra = precio_compra
        cultivo_a_editar.precio_venta = precio_venta
        cultivo_a_editar.dias_alerta = dias_alerta # <- ASIGNAR NUEVO VALOR
        msg = f"'{nombre}' actualizado con √©xito."
# ...

E. Actualizar manejar_editar_cultivo y limpiar_campos
Necesitamos mostrar el valor de la alerta al editar:

En manejar_editar_cultivo (cerca de la l√≠nea 324):

# ... (Dentro de manejar_editar_cultivo)
        cultivo_a_editar = lista_cultivos[indice]
        # ... (resto de campos)
        self.venta_var.set(f"{cultivo_a_editar.precio_venta:.2f}")
        self.dias_alerta_var.set(str(cultivo_a_editar.dias_alerta)) # <- MOSTRAR EL VALOR
        self.fecha_siembra_obj = cultivo_a_editar.fecha_siembra
# ...

En limpiar_campos (cerca de la l√≠nea 141):
# ... (Dentro de limpiar_campos)
        self.cosecha_display_var.set("Seleccionar fecha...")
        self.notas_var.set("")
        self.zona_var.set("")
        self.compra_var.set("")
        self.venta_var.set("")
        self.dias_alerta_var.set("7") # <- RESTAURAR VALOR POR DEFECTO
        self.fecha_siembra_obj = None
# ...

2. Implementaci√≥n de la L√≥gica de Alarma
Finalmente, modifica la funci√≥n revisar_cosechas_al_inicio (cerca de la l√≠nea 565) para que compruebe tanto la cosecha de hoy como las alertas tempranas.

Reemplaza la funci√≥n completa revisar_cosechas_al_inicio por esta nueva versi√≥n

def revisar_cosechas_al_inicio(self):
        """Revisa si hay cultivos listos para cosechar o que necesitan una alerta temprana."""
        hoy = datetime.date.today()
        cosechas_hoy = []
        alertas_tempranas = []
        
        for cultivo in lista_cultivos:
            dias_restantes = (cultivo.fecha_cosecha - hoy).days
            
            if dias_restantes < 0:
                # Cultivo ya cosechado
                continue
            elif dias_restantes == 0:
                # Cosecha hoy
                cosechas_hoy.append(cultivo.nombre)
            elif 0 < dias_restantes <= cultivo.dias_alerta:
                # Alerta temprana: entre 1 d√≠a y los 'dias_alerta' configurados
                alertas_tempranas.append(f"{cultivo.nombre} (Cosecha en {dias_restantes} d√≠as)")

        
        mensaje = ""
        titulo = ""
        
        if cosechas_hoy:
            mensaje += "‚ö†Ô∏è ¬°COSECHA PENDIENTE HOY! ‚ö†Ô∏è\n" + ", ".join(cosechas_hoy)
            titulo = "¬°ALERTA M√ÅXIMA!"
        
        if alertas_tempranas:
            if mensaje:
                mensaje += "\n\n"
            mensaje += "üîî Preparaci√≥n de Cosecha:\n" + "\n".join(alertas_tempranas)
            if not titulo:
                 titulo = "Alerta Temprana"

        if mensaje:
            self.recordatorio_label.config(text=mensaje, style='Alerta.TLabel')
            messagebox.showwarning(titulo, mensaje)
        else:
            self.recordatorio_label.config(text="Todo al d√≠a. Ninguna cosecha ni alerta activa.", style='TLabel', foreground=COLOR_ENFASIS_VERDE)

Con estos cambios, tu aplicaci√≥n ahora es capaz de gestionar alarmas personalizadas para cada cultivo.

¬øDeseas que te muestre el c√≥digo completo de cultivos.py con todas estas modificaciones antes de pasar al √∫ltimo objetivo (Desarrollo Web / Backend)?


¬°Excelente! Pasar al Desarrollo Web con Flask es el siguiente gran hito. Esto te dar√° la flexibilidad de acceder y, potencialmente, modificar tus datos de cultivos desde cualquier dispositivo a trav√©s de un navegador web, movi√©ndote de una aplicaci√≥n puramente local a una soluci√≥n cliente-servidor.

Vamos a empezar con el backend.

Fase 1: Configuraci√≥n del Backend (Flask)
El plan es crear un archivo app_backend.py que correr√° el servidor, leer√° cultivos.json y lo expondr√° a trav√©s de una API REST simple.

1. Requisito Adicional
Si a√∫n no lo tienes instalado, abre tu terminal o entorno virtual y ejecuta:

pip install flask

2. C√≥digo del Servidor Flask (app_backend.py)
Crea un nuevo archivo en la misma carpeta que cultivos.py y cultivos.json llamado app_backend.py.

Este c√≥digo inicia un servidor muy b√°sico y tiene una ruta principal para obtener todos los datos de cultivos.
# app_backend.py

from flask import Flask, jsonify, request
import json
import os
from datetime import datetime

# --- CONFIGURACI√ìN ---
NOMBRE_ARCHIVO_CULTIVOS = "cultivos.json"

# Inicializaci√≥n de la aplicaci√≥n Flask
app = Flask(__name__)

# Funci√≥n para cargar los datos del JSON
def cargar_datos_cultivos():
    """Lee el archivo JSON de cultivos. Si no existe, devuelve una lista vac√≠a."""
    if not os.path.exists(NOMBRE_ARCHIVO_CULTIVOS):
        return []
    try:
        with open(NOMBRE_ARCHIVO_CULTIVOS, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Error al cargar datos JSON: {e}")
        return []

# --- RUTAS DE LA API (Endpoints) ---

@app.route('/', methods=['GET'])
def index():
    """Ruta de bienvenida/prueba."""
    return jsonify({
        "status": "ok",
        "mensaje": "Servidor de Asistente de Cultivos (API) activo.",
        "endpoints_disponibles": {
            "/api/v1/cultivos": "GET (Obtiene todos los cultivos)"
        }
    })


@app.route('/api/v1/cultivos', methods=['GET'])
def obtener_cultivos():
    """
    Endpoint para obtener la lista completa de cultivos.
    """
    cultivos = cargar_datos_cultivos()
    
    # Opcional: A√±adir un campo "dias_restantes" din√°mico a cada cultivo antes de enviarlo.
    hoy = datetime.now().date()
    
    for cultivo in cultivos:
        try:
            fecha_cosecha = datetime.strptime(cultivo["fecha_cosecha"], '%Y-%m-%d').date()
            dias_restantes = (fecha_cosecha - hoy).days
            
            # Formateamos el resultado de forma m√°s amigable
            if dias_restantes < 0:
                cultivo['dias_restantes'] = f"Cosechado hace {abs(dias_restantes)} d√≠as"
            elif dias_restantes == 0:
                cultivo['dias_restantes'] = "¬°COSECHA HOY!"
            else:
                cultivo['dias_restantes'] = f"{dias_restantes} d√≠as"
                
        except (ValueError, KeyError):
            cultivo['dias_restantes'] = "Fecha no v√°lida"
            
    return jsonify(cultivos)


# --- INICIO DEL SERVIDOR ---
if __name__ == '__main__':
    # Ejecuta el servidor en modo debug para desarrollo.
    # Se ejecutar√° en http://127.0.0.1:5000/
    print("Iniciando servidor Flask...")
    app.run(debug=True)
Asistente de programaci√≥n
¬°Excelente! Pasar al Desarrollo Web con Flask es el siguiente gran hito. Esto te dar√° la flexibilidad de acceder y, potencialmente, modificar tus datos de cultivos desde cualquier dispositivo a trav√©s de un navegador web, movi√©ndote de una aplicaci√≥n puramente local a una soluci√≥n cliente-servidor.

Vamos a empezar con el backend.

üöÄ Fase 1: Configuraci√≥n del Backend (Flask)
El plan es crear un archivo app_backend.py que correr√° el servidor, leer√° cultivos.json y lo expondr√° a trav√©s de una API REST simple.

1. Requisito Adicional
Si a√∫n no lo tienes instalado, abre tu terminal o entorno virtual y ejecuta:

Bash
pip install flask
2. C√≥digo del Servidor Flask (app_backend.py)
Crea un nuevo archivo en la misma carpeta que cultivos.py y cultivos.json llamado app_backend.py.

Este c√≥digo inicia un servidor muy b√°sico y tiene una ruta principal para obtener todos los datos de cultivos.

Python
# app_backend.py

from flask import Flask, jsonify, request
import json
import os
from datetime import datetime

# --- CONFIGURACI√ìN ---
NOMBRE_ARCHIVO_CULTIVOS = "cultivos.json"

# Inicializaci√≥n de la aplicaci√≥n Flask
app = Flask(__name__)

# Funci√≥n para cargar los datos del JSON
def cargar_datos_cultivos():
    """Lee el archivo JSON de cultivos. Si no existe, devuelve una lista vac√≠a."""
    if not os.path.exists(NOMBRE_ARCHIVO_CULTIVOS):
        return []
    try:
        with open(NOMBRE_ARCHIVO_CULTIVOS, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Error al cargar datos JSON: {e}")
        return []

# --- RUTAS DE LA API (Endpoints) ---

@app.route('/', methods=['GET'])
def index():
    """Ruta de bienvenida/prueba."""
    return jsonify({
        "status": "ok",
        "mensaje": "Servidor de Asistente de Cultivos (API) activo.",
        "endpoints_disponibles": {
            "/api/v1/cultivos": "GET (Obtiene todos los cultivos)"
        }
    })


@app.route('/api/v1/cultivos', methods=['GET'])
def obtener_cultivos():
    """
    Endpoint para obtener la lista completa de cultivos.
    """
    cultivos = cargar_datos_cultivos()
    
    # Opcional: A√±adir un campo "dias_restantes" din√°mico a cada cultivo antes de enviarlo.
    hoy = datetime.now().date()
    
    for cultivo in cultivos:
        try:
            fecha_cosecha = datetime.strptime(cultivo["fecha_cosecha"], '%Y-%m-%d').date()
            dias_restantes = (fecha_cosecha - hoy).days
            
            # Formateamos el resultado de forma m√°s amigable
            if dias_restantes < 0:
                cultivo['dias_restantes'] = f"Cosechado hace {abs(dias_restantes)} d√≠as"
            elif dias_restantes == 0:
                cultivo['dias_restantes'] = "¬°COSECHA HOY!"
            else:
                cultivo['dias_restantes'] = f"{dias_restantes} d√≠as"
                
        except (ValueError, KeyError):
            cultivo['dias_restantes'] = "Fecha no v√°lida"
            
    return jsonify(cultivos)


# --- INICIO DEL SERVIDOR ---
if __name__ == '__main__':
    # Ejecuta el servidor en modo debug para desarrollo.
    # Se ejecutar√° en http://127.0.0.1:5000/
    print("Iniciando servidor Flask...")
    app.run(debug=True)
3. Instrucciones de Implementaci√≥n
Guarda el Archivo: Aseg√∫rate de guardar el c√≥digo anterior como app_backend.py en la misma carpeta que cultivos.py.

Inicia el Servidor: Abre tu terminal, navega a la carpeta donde guardaste el archivo y ejecuta:

python app_backend.py

Ver√°s un mensaje similar a: Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

Prueba la API:

Abre tu navegador (o una herramienta como Postman) y visita: http://127.0.0.1:5000/

Visita la ruta de datos: http://127.0.0.1:5000/api/v1/cultivos
Deber√≠as ver tus datos de cultivos.json directamente en el navegador, incluyendo el campo din√°mico dias_restantes que calculamos en el servidor.

Ahora que el servidor est√° corriendo y sirviendo tus datos, el siguiente paso l√≥gico es implementar una ruta que te permita agregar nuevos cultivos a trav√©s de la web (peticiones POST).

Modificaciones en app_backend.py (Ruta POST)
A√±ade las siguientes funciones y la ruta a tu archivo app_backend.py.

1. Nueva Funci√≥n para Guardar Datos
Inserta la siguiente funci√≥n justo despu√©s de la funci√≥n cargar_datos_cultivos:

# app_backend.py (cerca de la l√≠nea 20)

# ... (Funci√≥n cargar_datos_cultivos)

def guardar_datos_cultivos(cultivos_lista):
    """Escribe la lista de cultivos actualizada en el archivo JSON."""
    try:
        with open(NOMBRE_ARCHIVO_CULTIVOS, "w") as f:
            # Usamos indent=4 para que el JSON sea legible, como lo hac√≠a la app de escritorio
            json.dump(cultivos_lista, f, indent=4)
        return True
    except Exception as e:
        print(f"Error al guardar datos JSON: {e}")
        return False

# ...
2. Nueva Ruta POST para Agregar Cultivos
A√±ade esta nueva ruta dentro de la secci√≥n de RUTAS DE LA API

# app_backend.py (cerca de la l√≠nea 60)

# ... (Funci√≥n obtener_cultivos)

@app.route('/api/v1/cultivos', methods=['POST'])
def agregar_cultivo():
    """
    Endpoint para agregar un nuevo cultivo a la base de datos.
    Requiere un objeto JSON con los campos necesarios.
    """
    if not request.json:
        return jsonify({"error": "Falta el cuerpo de la petici√≥n (JSON)."}), 400

    datos_cultivo = request.json
    
    # 1. Validaci√≥n B√°sica de Campos Requeridos
    campos_requeridos = ["nombre", "fecha_siembra", "fecha_cosecha"]
    for campo in campos_requeridos:
        if campo not in datos_cultivo:
            return jsonify({"error": f"Falta el campo requerido: {campo}"}), 400
            
    # 2. Convertir y validar fechas
    try:
        # Verifica que el formato de fecha sea YYYY-MM-DD
        datetime.strptime(datos_cultivo["fecha_siembra"], '%Y-%m-%d')
        datetime.strptime(datos_cultivo["fecha_cosecha"], '%Y-%m-%d')
    except ValueError:
        return jsonify({"error": "Formato de fecha inv√°lido. Use YYYY-MM-DD."}), 400

    # 3. Preparar el nuevo objeto (Asegurar que todos los campos existan con valores predeterminados si faltan)
    nuevo_cultivo = {
        "nombre": datos_cultivo["nombre"],
        "fecha_siembra": datos_cultivo["fecha_siembra"],
        "fecha_cosecha": datos_cultivo["fecha_cosecha"],
        "notas": datos_cultivo.get("notas", ""),
        "zona": datos_cultivo.get("zona", ""),
        # Asegurar que los valores num√©ricos son float/int
        "precio_compra": float(datos_cultivo.get("precio_compra", 0.0)),
        "precio_venta": float(datos_cultivo.get("precio_venta", 0.0)),
        "dias_alerta": int(datos_cultivo.get("dias_alerta", 0))
    }
    
    # 4. Cargar, A√±adir y Guardar
    cultivos = cargar_datos_cultivos()
    cultivos.append(nuevo_cultivo)
    
    if guardar_datos_cultivos(cultivos):
        return jsonify({
            "status": "success",
            "mensaje": f"Cultivo '{nuevo_cultivo['nombre']}' a√±adido correctamente.",
            "cultivo_agregado": nuevo_cultivo
        }), 201  # C√≥digo 201 Created
    else:
        return jsonify({"error": "Error interno del servidor al guardar el archivo."}), 500

. Prueba de Implementaci√≥n (POST)
Ahora que tienes la ruta POST, puedes probarla usando una herramienta como Postman, la extensi√≥n Thunder Client en VS Code, o incluso la l√≠nea de comandos con curl.

Ejemplo de Petici√≥n JSON (Cuerpo de la Petici√≥n):

{
    "nombre": "Cebolla Morada",
    "fecha_siembra": "2025-11-05",
    "fecha_cosecha": "2026-03-20",
    "zona": "Zona D",
    "precio_compra": 150.50,
    "precio_venta": 420.00,
    "dias_alerta": 10
}

Reinicia el servidor Flask (presiona Ctrl+C y luego python app_backend.py).

Env√≠a una petici√≥n POST a http://127.0.0.1:5000/api/v1/cultivos con el JSON de ejemplo.

Verifica que el archivo cultivos.json se ha actualizado con el nuevo cultivo.

Una vez que hayas verificado que puedes agregar datos de forma remota, podemos continuar con las funcionalidades CRUD (Crear, Leer, Actualizar, Eliminar).

Resumen de la API:Operaci√≥nM√©todoURLFunci√≥nLeer (todos)GET/api/v1/cultivosListar todos los cultivos.CrearPOST/api/v1/cultivosA√±adir un nuevo cultivo (requiere JSON).ActualizarPUT/api/v1/cultivos/<nombre>Reemplazar/Actualizar todos los datos de un cultivo (requiere JSON).EliminarDELETE/api/v1/cultivos/<nombre>Eliminar un cultivo por su nombre.Hemos terminado la fase de Desarrollo Web (Backend). El siguiente y √∫ltimo objetivo de tu lista era:

Operaci√≥n,M√©todo,URL,Funci√≥n
Leer (todos),GET,/api/v1/cultivos,Listar todos los cultivos.
Crear,POST,/api/v1/cultivos,A√±adir un nuevo cultivo (requiere JSON).
Actualizar,PUT,/api/v1/cultivos/<nombre>,Reemplazar/Actualizar todos los datos de un cultivo (requiere JSON).
Eliminar,DELETE,/api/v1/cultivos/<nombre>,Eliminar un cultivo por su nombre.

Asistente de programaci√≥n
¬°Excelente! Vamos a lanzar la aplicaci√≥n para verificar que todo el c√≥digo del backend, incluyendo el CRUD completo, est√© funcionando.

üöÄ Prueba del Servidor Flask
Abre tu Terminal/S√≠mbolo del Sistema (si no lo tienes abierto o est√° ocupado con la ejecuci√≥n anterior).

Aseg√∫rate de estar en la carpeta donde guardaste el archivo app_backend.py.

Ejecuta el servidor con el comando:

python app_backend.py

Deber√≠as ver una salida similar a esta, indicando que el servidor est√° corriendo en el puerto 5000:

Iniciando servidor Flask...
 * Serving Flask app 'app_backend'
 * Debug mode: on
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
 * Restarting with stat
Iniciando servidor Flask...
 * Debugger is active!
 * Debugger PIN: XXX-XXX-XXX

Prueba de Lectura (GET)
Abre tu navegador y navega a la URL base de tu API:

URL: http://127.0.0.1:5000/

Resultado esperado: Debes ver el mensaje de bienvenida y la lista de los cuatro endpoints CRUD que acabamos de implementar.

{
  "endpoints_disponibles": {
    "/api/v1/cultivos (DELETE)": "Elimina un cultivo por nombre",
    "/api/v1/cultivos (GET)": "Obtiene todos los cultivos",
    "/api/v1/cultivos (POST)": "Agrega un nuevo cultivo",
    "/api/v1/cultivos (PUT)": "Actualiza completamente un cultivo por nombre"
  },
  "mensaje": "Servidor de Asistente de Cultivos (API) activo.",
  "status": "ok"
}

Ahora, visita la URL de los cultivos:

URL: http://127.0.0.1:5000/api/v1/cultivos

Resultado esperado: Deber√≠as ver tus datos de cultivos.json como una lista JSON, incluyendo el campo calculado dias_restantes para cada cultivo.

2. Siguiente Paso
El backend ya est√° completo con la API RESTful. Ahora, el siguiente y √∫ltimo paso seg√∫n tu plan original es construir la interfaz web.

¬øEst√°s listo para crear la interfaz de usuario web (Frontend) (HTML, CSS y JavaScript) que se conectar√° a esta API?

Asistente de programaci√≥n
¬°Absolutamente! Estoy listo para empezar con el Frontend.

La interfaz web simple la construiremos con tres archivos esenciales, todos en la misma carpeta:

index.html: La estructura base de la p√°gina.

styles.css: El estilo visual (usaremos un tema oscuro simple).

scripts.js: La l√≥gica para interactuar con la API (peticiones GET, POST, PUT, DELETE).

üöÄ Fase 2: Desarrollo del Frontend Web
Vamos a empezar con la estructura de la p√°gina.

1. Creaci√≥n del Archivo HTML (index.html)
Crea un archivo llamado index.html en la misma carpeta que tus archivos Python.

Este HTML definir√° la tabla para mostrar los cultivos y el formulario para a√±adir/editar uno nuevo.
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Cultivos (Web API)</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <header>
        <h1>üå± Gestor de Cultivos API</h1>
    </header>

    <main>
        <section class="card" id="form-section">
            <h2>‚úèÔ∏è A√±adir / Editar Cultivo</h2>
            <form id="cultivoForm">
                <input type="hidden" id="cultivoNombreOriginal" value="">
                
                <label for="nombre">Nombre:</label>
                <input type="text" id="nombre" required>

                <label for="zona">Zona:</label>
                <input type="text" id="zona">

                <label for="fecha_siembra">Fecha Siembra:</label>
                <input type="date" id="fecha_siembra" required>

                <label for="fecha_cosecha">Fecha Cosecha:</label>
                <input type="date" id="fecha_cosecha" required>

                <div class="split">
                    <div>
                        <label for="precio_compra">Costo (‚Ç¨):</label>
                        <input type="number" id="precio_compra" step="0.01" value="0.00">
                    </div>
                    <div>
                        <label for="precio_venta">Venta Est. (‚Ç¨):</label>
                        <input type="number" id="precio_venta" step="0.01" value="0.00">
                    </div>
                </div>
                
                <label for="dias_alerta">D√≠as de Alerta (Previos a Cosecha):</label>
                <input type="number" id="dias_alerta" value="7">

                <label for="notas">Notas:</label>
                <textarea id="notas"></textarea>

                <button type="submit" id="submitButton">A√±adir Cultivo</button>
            </form>
        </section>

        <section class="card" id="list-section">
            <h2>üóì Mis Cultivos</h2>
            <p id="loading-message">Cargando datos de la API...</p>

            <table id="cultivoTable">
                <thead>
                    <tr>
                        <th>Nombre</th>
                        <th>Zona</th>
                        <th>Siembra</th>
                        <th>Cosecha</th>
                        <th>Faltan</th>
                        <th>Margen Est.</th>
                        <th>Acciones</th>
                    </tr>
                </thead>
                <tbody id="cultivoList">
                    </tbody>
            </table>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 Asistente de Cultivos Web API</p>
    </footer>

    <script src="scripts.js"></script>
</body>
</html>

2. Creaci√≥n del Archivo CSS (styles.css)
Crea un archivo llamado styles.css para darle un tema oscuro a la aplicaci√≥n.

/* styles.css */

:root {
    --color-dark-bg: #1e1e1e;
    --color-card-bg: #2d2d2d;
    --color-text: #f0f0f0;
    --color-primary: #5cb85c; /* Verde */
    --color-secondary: #007bff; /* Azul */
    --color-danger: #dc3545; /* Rojo */
    --color-alert: #ffc107; /* Amarillo */
}

/* Estilos Generales */
body {
    font-family: Arial, sans-serif;
    background-color: var(--color-dark-bg);
    color: var(--color-text);
    margin: 0;
    padding: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
}

header {
    background-color: var(--color-card-bg);
    width: 100%;
    text-align: center;
    padding: 20px 0;
    margin-bottom: 20px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
}

h1 {
    color: var(--color-primary);
    margin: 0;
}

main {
    display: flex;
    gap: 20px;
    max-width: 1200px;
    width: 90%;
    padding-bottom: 40px;
}

/* Estilos de las Tarjetas (Card) */
.card {
    background-color: var(--color-card-bg);
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    flex-grow: 1;
}

#form-section {
    flex-basis: 300px;
    flex-shrink: 0;
}

#list-section {
    flex-basis: 70%;
    overflow-x: auto;
}

h2 {
    color: var(--color-secondary);
    border-bottom: 2px solid var(--color-card-bg);
    padding-bottom: 10px;
    margin-top: 0;
}

/* Estilos del Formulario */
form label {
    display: block;
    margin-top: 10px;
    font-size: 0.9em;
}

form input[type="text"],
form input[type="date"],
form input[type="number"],
form textarea {
    width: 100%;
    padding: 8px;
    margin-top: 5px;
    box-sizing: border-box;
    border: 1px solid #444;
    background-color: #383838;
    color: var(--color-text);
    border-radius: 4px;
}

.split {
    display: flex;
    gap: 10px;
    margin-bottom: 10px;
}
.split > div {
    flex-basis: 50%;
}

button {
    background-color: var(--color-primary);
    color: var(--color-text);
    padding: 10px 15px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    margin-top: 15px;
    transition: background-color 0.3s;
    font-weight: bold;
}

button:hover {
    background-color: #4CAF50;
}

/* Estilos de la Tabla */
#cultivoTable {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

#cultivoTable th, #cultivoTable td {
    border: 1px solid #444;
    padding: 10px;
    text-align: left;
    white-space: nowrap; /* Evita que el texto de la tabla se rompa */
}

#cultivoTable th {
    background-color: #495057;
    color: var(--color-text);
    font-weight: bold;
    text-align: center;
}

/* Clases de color para el estado de la cosecha */
.cosecha-pasada {
    background-color: #444;
    color: #aaa;
}
.cosecha-hoy {
    background-color: var(--color-alert);
    color: var(--color-dark-bg);
    font-weight: bold;
}
.cosecha-futura {
    background-color: #383838;
}

/* Botones de acci√≥n dentro de la tabla */
.action-buttons button {
    margin: 0 5px;
    padding: 5px 8px;
    font-size: 0.8em;
    margin-top: 0;
}

.edit-btn {
    background-color: var(--color-secondary);
}
.delete-btn {
    background-color: var(--color-danger);
}
.edit-btn:hover {
    background-color: #0056b3;
}
.delete-btn:hover {
    background-color: #c82333;
}

/* Footer */
footer {
    width: 100%;
    text-align: center;
    padding: 10px 0;
    background-color: var(--color-card-bg);
    color: #888;
    margin-top: auto; /* Empuja el footer hacia abajo */
}

. Siguiente Paso
Con la estructura (HTML) y el estilo (CSS) listos, el paso cr√≠tico es implementar la l√≥gica de comunicaci√≥n con el servidor.

¬øEst√°s listo para crear el archivo scripts.js con las funciones para GET, POST, PUT y DELETE?

Excelente! Esta es la fase m√°s importante del frontend, ya que conectar√° el HTML/CSS con la API de Flask que has construido.

Crea un archivo llamado scripts.js en la misma carpeta que index.html y styles.css.

Este c√≥digo maneja todo: desde cargar la lista al inicio hasta gestionar el env√≠o de formularios y los botones de la tabla.

üíª C√≥digo JavaScript (scripts.js)

// scripts.js

// --- CONFIGURACI√ìN ---
const API_BASE_URL = 'http://127.0.0.1:5000/api/v1/cultivos';
const tableBody = document.getElementById('cultivoList');
const form = document.getElementById('cultivoForm');
const submitButton = document.getElementById('submitButton');
const originalNameInput = document.getElementById('cultivoNombreOriginal');
const loadingMessage = document.getElementById('loading-message');

let modoEdicion = false; // Bandera para saber si estamos a√±adiendo o editando

// --- FUNCIONES DE MANEJO DE LA API (CRUD) ---

/**
 * 1. GET (Leer): Carga y renderiza todos los cultivos.
 */
async function cargarCultivos() {
    loadingMessage.textContent = 'Cargando datos de la API...';
    try {
        const response = await fetch(API_BASE_URL);
        const cultivos = await response.json();
        
        loadingMessage.style.display = 'none'; // Ocultar mensaje de carga
        renderizarTabla(cultivos);

    } catch (error) {
        console.error('Error al cargar cultivos:', error);
        loadingMessage.textContent = 'ERROR: No se pudo conectar con el servidor Flask. Aseg√∫rate de que est√© corriendo en http://127.0.0.1:5000.';
        loadingMessage.style.color = 'var(--color-danger)';
    }
}

/**
 * 2. POST / PUT (Crear / Actualizar): Env√≠a datos del formulario a la API.
 */
async function manejarEnvioFormulario(event) {
    event.preventDefault(); // Detener el env√≠o por defecto

    const datosCultivo = obtenerDatosFormulario();

    if (!datosCultivo.nombre || !datosCultivo.fecha_siembra || !datosCultivo.fecha_cosecha) {
        alert('Por favor, rellena el nombre, la fecha de siembra y la fecha de cosecha.');
        return;
    }

    const nombreOriginal = originalNameInput.value;
    let url = API_BASE_URL;
    let method = 'POST';
    
    // Si estamos en modo edici√≥n, cambiamos el m√©todo y la URL
    if (modoEdicion) {
        url = `${API_BASE_URL}/${nombreOriginal}`;
        method = 'PUT';
    }

    try {
        const response = await fetch(url, {
            method: method,
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(datosCultivo),
        });

        const resultado = await response.json();

        if (response.ok) {
            alert(resultado.mensaje || (modoEdicion ? 'Cultivo actualizado.' : 'Cultivo a√±adido.'));
            resetFormulario();
            cargarCultivos(); // Recargar la tabla
        } else {
            alert(`Error ${response.status}: ${resultado.error || 'Algo sali√≥ mal en el servidor.'}`);
        }
    } catch (error) {
        console.error('Error al enviar el formulario:', error);
        alert('Error de conexi√≥n con la API.');
    }
}

/**
 * 3. DELETE (Eliminar): Elimina un cultivo por nombre.
 */
async function eliminarCultivo(nombreCultivo) {
    if (!confirm(`¬øEst√°s seguro de que deseas eliminar el cultivo: ${nombreCultivo}?`)) {
        return;
    }

    try {
        const response = await fetch(`${API_BASE_URL}/${nombreCultivo}`, {
            method: 'DELETE',
        });

        const resultado = await response.json();

        if (response.ok) {
            alert(resultado.mensaje || 'Cultivo eliminado.');
            cargarCultivos(); // Recargar la tabla
        } else {
            alert(`Error ${response.status}: ${resultado.error || 'No se pudo eliminar el cultivo.'}`);
        }
    } catch (error) {
        console.error('Error al eliminar:', error);
        alert('Error de conexi√≥n con la API.');
    }
}


// --- FUNCIONES DE UTILIDAD Y RENDERIZADO ---

/**
 * Recopila los datos del formulario.
 */
function obtenerDatosFormulario() {
    return {
        nombre: document.getElementById('nombre').value.trim(),
        zona: document.getElementById('zona').value.trim(),
        fecha_siembra: document.getElementById('fecha_siembra').value,
        fecha_cosecha: document.getElementById('fecha_cosecha').value,
        precio_compra: parseFloat(document.getElementById('precio_compra').value) || 0.0,
        precio_venta: parseFloat(document.getElementById('precio_venta').value) || 0.0,
        dias_alerta: parseInt(document.getElementById('dias_alerta').value) || 0,
        notas: document.getElementById('notas').value.trim(),
    };
}

/**
 * Pinta la tabla HTML con los datos obtenidos de la API.
 */
function renderizarTabla(cultivos) {
    tableBody.innerHTML = '';
    cultivos.forEach(cultivo => {
        const row = tableBody.insertRow();
        let claseCosecha = 'cosecha-futura';
        
        // Determinar la clase CSS seg√∫n el estado de d√≠as_restantes
        if (cultivo.dias_restantes.includes('COSECHA HOY')) {
            claseCosecha = 'cosecha-hoy';
        } else if (cultivo.dias_restantes.includes('Cosechado hace')) {
            claseCosecha = 'cosecha-pasada';
        }
        
        // Calcular margen potencial
        const margen = (cultivo.precio_venta - cultivo.precio_compra).toFixed(2);
        
        // Renderizado de las celdas
        row.insertCell().textContent = cultivo.nombre;
        row.insertCell().textContent = cultivo.zona;
        row.insertCell().textContent = cultivo.fecha_siembra;
        row.insertCell().textContent = cultivo.fecha_cosecha;
        
        const cellFaltan = row.insertCell();
        cellFaltan.textContent = cultivo.dias_restantes;
        cellFaltan.classList.add(claseCosecha);
        
        row.insertCell().textContent = `‚Ç¨${margen}`;

        // Celda de Acciones (Botones)
        const cellAcciones = row.insertCell();
        cellAcciones.classList.add('action-buttons');
        
        const btnEditar = document.createElement('button');
        btnEditar.textContent = 'Editar';
        btnEditar.classList.add('edit-btn');
        btnEditar.onclick = () => cargarParaEdicion(cultivo);
        
        const btnEliminar = document.createElement('button');
        btnEliminar.textContent = 'Eliminar';
        btnEliminar.classList.add('delete-btn');
        btnEliminar.onclick = () => eliminarCultivo(cultivo.nombre);
        
        cellAcciones.appendChild(btnEditar);
        cellAcciones.appendChild(btnEliminar);
    });
}

/**
 * Carga los datos de un cultivo seleccionado al formulario para su edici√≥n.
 */
function cargarParaEdicion(cultivo) {
    // 1. Cargar datos al formulario
    document.getElementById('nombre').value = cultivo.nombre;
    document.getElementById('zona').value = cultivo.zona;
    document.getElementById('fecha_siembra').value = cultivo.fecha_siembra;
    document.getElementById('fecha_cosecha').value = cultivo.fecha_cosecha;
    document.getElementById('precio_compra').value = cultivo.precio_compra.toFixed(2);
    document.getElementById('precio_venta').value = cultivo.precio_venta.toFixed(2);
    document.getElementById('dias_alerta').value = cultivo.dias_alerta;
    document.getElementById('notas').value = cultivo.notas;
    
    // 2. Configurar el modo edici√≥n
    modoEdicion = true;
    originalNameInput.value = cultivo.nombre; // Guardar el nombre original para la URL PUT/DELETE
    submitButton.textContent = `Guardar Cambios de ${cultivo.nombre}`;
    submitButton.classList.add('edit-btn');
    submitButton.classList.remove('delete-btn');
    
    // Opcional: Desplazar la vista al formulario para que el usuario pueda editar inmediatamente
    document.getElementById('form-section').scrollIntoView({ behavior: 'smooth' });
}

/**
 * Limpia el formulario y vuelve al modo A√±adir.
 */
function resetFormulario() {
    form.reset();
    modoEdicion = false;
    originalNameInput.value = '';
    submitButton.textContent = 'A√±adir Cultivo';
    submitButton.classList.remove('edit-btn');
    submitButton.classList.remove('delete-btn');
    // Asegurar valores por defecto despu√©s del reset()
    document.getElementById('precio_compra').value = '0.00';
    document.getElementById('precio_venta').value = '0.00';
    document.getElementById('dias_alerta').value = '7';
}


// --- INICIALIZACI√ìN ---

// Escucha el evento de env√≠o del formulario
form.addEventListener('submit', manejarEnvioFormulario);

// A√±ade un bot√≥n de "Cancelar Edici√≥n" si el usuario quiere volver al modo A√±adir
const btnCancelar = document.createElement('button');
btnCancelar.textContent = 'Limpiar / Cancelar Edici√≥n';
btnCancelar.classList.add('delete-btn');
btnCancelar.type = 'button'; // Importante para que no active el submit
btnCancelar.onclick = resetFormulario;
form.appendChild(btnCancelar);

// Carga los cultivos al iniciar la p√°gina
document.addEventListener('DOMContentLoaded', cargarCultivos);

Pasos Finales de la Implementaci√≥n Web
Guarda los tres archivos: Aseg√∫rate de que index.html, styles.css, y scripts.js est√©n en la misma carpeta.

Verifica el Backend: Confirma que tu servidor Flask (app_backend.py) est√© corriendo en tu terminal (ejecuta python app_backend.py).

Abre el Frontend: Abre el archivo index.html directamente en tu navegador (haz doble clic en √©l).

Si todo est√° correcto, deber√≠as ver la interfaz web cargarse, y la tabla se poblar√° autom√°ticamente con los datos de tu cultivos.json que son servidos por la API de Flask.

¬°El sistema de gesti√≥n de cultivos ya es una aplicaci√≥n completa, incluyendo GUI de escritorio y una interfaz web conectada a una API!


Basado en la estructura actual de tu aplicaci√≥n (Backend Flask/JSON y Frontend HTML/JS), propongo la siguiente mejora funcional y de usabilidad:

Pr√≥xima Mejora: B√∫squeda y Filtrado Din√°mico de Cultivos (Frontend)
Actualmente, si la lista de cultivos crece, el usuario tendr√≠a dificultades para encontrar un elemento espec√≠fico. Vamos a a√±adir una barra de b√∫squeda en el frontend que filtre la tabla en tiempo real por Nombre, Zona o Notas, sin necesidad de llamar a la API nuevamente.

Esto es un ejercicio excelente de manipulaci√≥n de DOM con JavaScript.

üìù Modificaci√≥n del HTML (index.html)
A√±ade un campo de b√∫squeda justo encima de la tabla de cultivos.

Busca la secci√≥n <section class="card" id="list-section"> y agrega el siguiente div despu√©s del <h2>:

<section class="card" id="list-section">
    <h2>üóì Mis Cultivos</h2>
    
    <div id="search-container">
        <label for="cultivoSearch">üîç Buscar Cultivo:</label>
        <input type="text" id="cultivoSearch" placeholder="Escribe nombre, zona o nota para filtrar...">
    </div>
    <p id="loading-message">Cargando datos de la API...</p>

    </section>

üé® Modificaci√≥n del CSS (styles.css)
A√±ade estilos simples para la nueva barra de b√∫squeda:

/* styles.css (A√±adir al final del archivo) */

/* Estilos para el contenedor de b√∫squeda */
#search-container {
    padding: 10px 0;
    border-top: 1px solid #444;
}

#cultivoSearch {
    width: 100%;
    padding: 10px;
    margin-top: 5px;
    box-sizing: border-box;
    border: 1px solid #555;
    background-color: #383838;
    color: var(--color-text);
    border-radius: 4px;
}

üíª Modificaci√≥n del JavaScript (scripts.js)
Aqu√≠ est√° la l√≥gica principal. Necesitamos: a. Almacenar los datos de los cultivos globalmente. b. Una funci√≥n para filtrar la tabla bas√°ndose en el texto de b√∫squeda. c. Un event listener para detectar cuando el usuario escribe.

Abre scripts.js y haz los siguientes cambios:

A. Variables Globales (cerca de la l√≠nea 5)
A√±ade una variable global para guardar los datos cargados:

// scripts.js (cerca de la l√≠nea 5)

// --- CONFIGURACI√ìN ---
// ... (otras variables) ...
const searchInput = document.getElementById('cultivoSearch'); // <-- NUEVO
const loadingMessage = document.getElementById('loading-message');

let modoEdicion = false; 
let cultivosData = []; // <-- NUEVO: Almacenar los datos cargados
. Modificaci√≥n de cargarCultivos (cerca de la l√≠nea 15)
Modifica esta funci√≥n para guardar los datos globalmente antes de renderizar
// scripts.js (Modificaci√≥n de cargarCultivos)

async function cargarCultivos() {
    loadingMessage.textContent = 'Cargando datos de la API...';
    try {
        const response = await fetch(API_BASE_URL);
        const cultivos = await response.json();
        
        cultivosData = cultivos; // <-- GUARDAR los datos globalmente
        
        loadingMessage.style.display = 'none';
        renderizarTabla(cultivosData); // Renderizar todos al inicio

    } catch (error) {
        // ... (resto de manejo de error) ...
    }
}

Nueva Funci√≥n de Filtrado
A√±ade esta funci√≥n que filtra cultivosData y re-renderiza la tabla:

// scripts.js (A√±adir la nueva funci√≥n, por ejemplo, despu√©s de manejarEnvioFormulario)

/**
 * Filtra los cultivos mostrados en la tabla bas√°ndose en el texto de b√∫squeda.
 */
function filtrarCultivos() {
    const textoBusqueda = searchInput.value.toLowerCase().trim();
    
    if (textoBusqueda === '') {
        // Si no hay texto, mostrar todo
        renderizarTabla(cultivosData);
        return;
    }
    
    const cultivosFiltrados = cultivosData.filter(cultivo => {
        // Concatenar campos relevantes y buscar el texto en ellos
        const contenido = (
            cultivo.nombre + 
            cultivo.zona + 
            cultivo.notas + 
            cultivo.fecha_cosecha
        ).toLowerCase();
        
        return contenido.includes(textoBusqueda);
    });
    
    renderizarTabla(cultivosFiltrados);
}

Inicializaci√≥n (cerca de la l√≠nea 200)
A√±ade el event listener para que el filtrado se ejecute cada vez que el usuario escribe:

// scripts.js (A√±adir a la secci√≥n de inicializaci√≥n)

// ... (resto de la inicializaci√≥n) ...

// Escucha el evento 'input' en la barra de b√∫squeda para filtrar din√°micamente
searchInput.addEventListener('input', filtrarCultivos); // <-- NUEVO

// Carga los cultivos al iniciar la p√°gina
document.addEventListener('DOMContentLoaded', cargarCultivos);

Pr√≥ximo Paso
Guarda los tres archivos (index.html, styles.css, scripts.js).

Aseg√∫rate de que Flask est√© corriendo.

Recarga tu index.html en el navegador.

Ahora deber√≠as tener una barra de b√∫squeda funcional. Una vez que verifiques que el filtro funciona, ¬øquieres que abordemos la validaci√≥n de fechas en el frontend (por ejemplo, evitar que la fecha de cosecha sea anterior a la de siembra) como otra mejora de usabilidad?
Asistente de programaci√≥n
¬°Me parece una excelente mejora! La Validaci√≥n de Fechas en el Frontend evitar√° errores l√≥gicos antes de enviar los datos al servidor, mejorando la experiencia del usuario y la integridad de la base de datos.

Implementaremos una funci√≥n en JavaScript que se ejecuta cuando el usuario env√≠a el formulario. Esta funci√≥n verificar√° que la fecha de cosecha no sea anterior a la fecha de siembra.

üìù Modificaci√≥n del JavaScript (scripts.js)
Vamos a modificar las funciones manejarEnvioFormulario y obtenerDatosFormulario en tu archivo scripts.js.

1. Crear una Funci√≥n de Validaci√≥n de Fechas
A√±ade esta funci√≥n de utilidad para la validaci√≥n (puedes a√±adirla despu√©s de obtenerDatosFormulario):

JavaScript
// scripts.js (A√±adir a la secci√≥n de UTILIDAD Y RENDERIZADO)

/**
 * Valida que la fecha de cosecha sea posterior o igual a la fecha de siembra.
 * @returns {boolean} True si las fechas son v√°lidas, false si no.
 */
function validarFechas(siembraStr, cosechaStr) {
    // Convertir las cadenas de fecha (YYYY-MM-DD) a objetos Date
    // Usamos el formato Date.parse para comparar los milisegundos
    const siembra = Date.parse(siembraStr);
    const cosecha = Date.parse(cosechaStr);

    // Siembra y Cosecha son v√°lidas (no NaN) y Cosecha es anterior a Siembra
    if (siembra > cosecha) {
        return false;
    }
    return true;
}
2. Implementar la Validaci√≥n en el Manejo del Formulario
Ahora, actualiza la funci√≥n manejarEnvioFormulario para llamar a la nueva funci√≥n de validaci√≥n antes de hacer la llamada a la API.

Busca la funci√≥n manejarEnvioFormulario (cerca de la l√≠nea 40) y a√±ade el bloque de validaci√≥n.

JavaScript
// scripts.js (Modificaci√≥n de manejarEnvioFormulario)

async function manejarEnvioFormulario(event) {
    event.preventDefault(); // Detener el env√≠o por defecto

    const datosCultivo = obtenerDatosFormulario();

    if (!datosCultivo.nombre || !datosCultivo.fecha_siembra || !datosCultivo.fecha_cosecha) {
        alert('Por favor, rellena el nombre, la fecha de siembra y la fecha de cosecha.');
        return;
    }
    
    // -----------------------------------------------------------------
    //  NUEVA VALIDACI√ìN DE FECHAS (Frontend)
    // -----------------------------------------------------------------
    if (!validarFechas(datosCultivo.fecha_siembra, datosCultivo.fecha_cosecha)) {
        alert('‚ùå Error: La fecha de cosecha no puede ser anterior a la fecha de siembra.');
        // Evita que el c√≥digo contin√∫e con el fetch
        return; 
    }
    // -----------------------------------------------------------------

    const nombreOriginal = originalNameInput.value;
    // ... (El resto del c√≥digo del fetch sigue igual)
    // ...
}
3. ‚úÖ Prueba de la Mejora
Guarda el archivo scripts.js con la nueva funci√≥n y la modificaci√≥n en manejarEnvioFormulario.

Recarga index.html en tu navegador.

Intenta a√±adir o editar un cultivo con estas fechas:

Fecha Siembra: 2025-12-30

Fecha Cosecha: 2025-12-01

Resultado esperado: El sistema debe mostrar el mensaje de error: "‚ùå Error: La fecha de cosecha no puede ser anterior a la fecha de siembra." y NO debe enviar la petici√≥n a la API.

Con esta mejora, tu frontend es mucho m√°s inteligente y proporciona una mejor retroalimentaci√≥n al usuario.

¬øPudiste implementar y probar la validaci√≥n de fechas con √©xito? Si es as√≠, ¬øqu√© otra mejora quieres implementar, o preferir√≠as pasar a probar la eliminaci√≥n (DELETE) para cerrar el ciclo CRUD?


¬°Felicidades! Si las cuatro operaciones (Crear, Leer, Actualizar, Eliminar) funcionan correctamente a trav√©s de la interfaz web, has completado con √©xito todo el proyecto de gesti√≥n de cultivos que incluye:

Backend: API RESTful con Flask y manejo de datos JSON.

Frontend: Interfaz web funcional con HTML, CSS, JavaScript que consume la API, incluye b√∫squeda din√°mica y validaci√≥n de datos.

¬øQu√© te gustar√≠a hacer ahora? Por ejemplo, podemos:

A√±adir una funcionalidad de c√°lculo de rentabilidad y resumen al dashboard.

Implementar un sistema b√°sico de alerta de proximidad de cosecha.

Refinar la interfaz de usuario con mejoras visuales (CSS).

Asistente de programaci√≥n
¬°Perfecto! Abordaremos estas tres mejoras para llevar tu aplicaci√≥n al siguiente nivel. Estas mejoras se centran en el Frontend, ya que la l√≥gica de c√°lculo la haremos directamente en JavaScript, usando los datos ya cargados de la API.

Comenzaremos con la funcionalidad m√°s compleja que es el C√°lculo de Rentabilidad y Resumen para a√±adir valor de negocio a tu dashboard.

üåü Mejora 1: C√°lculo de Rentabilidad y Resumen
A√±adiremos un panel superior que muestre m√©tricas clave como el Costo Total, la Venta Total Estimada y la Ganancia Potencial Total.

1. üìù Modificaci√≥n del HTML (index.html)
A√±ade un nuevo contenedor (<section>) en el main de tu index.html, justo despu√©s del <header> y antes de la secci√≥n del formulario (<section class="card" id="form-section">).

HTML
<main>
    <section id="resumen-financiero" class="card">
        <h2>üìä Resumen Financiero Estimado</h2>
        <div class="kpis">
            <div class="kpi-item">
                <h3>Costo Total</h3>
                <p id="kpiCosto">‚Ç¨0.00</p>
            </div>
            <div class="kpi-item">
                <h3>Venta Total Estimada</h3>
                <p id="kpiVenta">‚Ç¨0.00</p>
            </div>
            <div class="kpi-item profit">
                <h3>Ganancia Potencial</h3>
                <p id="kpiGanancia">‚Ç¨0.00</p>
            </div>
        </div>
    </section>
    <section class="card" id="form-section">
        </section>
    
    </main>
2. üé® Modificaci√≥n del CSS (styles.css)
A√±ade los estilos para el nuevo panel de m√©tricas (KPIs). Puedes a√±adir este bloque al final de tu archivo styles.css.

CSS
/* styles.css (A√±adir al final del archivo) */

/* Estilos para el Resumen Financiero */
#resumen-financiero {
    width: 100%;
    margin-bottom: 20px;
    padding: 15px 20px;
}

#resumen-financiero h2 {
    border-bottom: none;
    margin-bottom: 15px;
}

.kpis {
    display: flex;
    justify-content: space-around;
    gap: 15px;
    text-align: center;
}

.kpi-item {
    background-color: #383838;
    padding: 10px 15px;
    border-radius: 6px;
    flex-grow: 1;
    border-left: 5px solid var(--color-secondary);
}

.kpi-item h3 {
    margin: 0 0 5px 0;
    font-size: 0.9em;
    color: #ccc;
}

.kpi-item p {
    margin: 0;
    font-size: 1.5em;
    font-weight: bold;
}

.profit {
    border-left: 5px solid var(--color-primary); /* Verde para la ganancia */
}
3. üíª Modificaci√≥n del JavaScript (scripts.js)
Implementaremos la funci√≥n para calcular y mostrar el resumen. Esta funci√≥n debe llamarse cada vez que se cargan o modifican los datos.

Abre scripts.js y haz los siguientes cambios:

A. Nueva Funci√≥n de C√°lculo de KPIs
A√±ade la siguiente funci√≥n, por ejemplo, despu√©s de filtrarCultivos:

JavaScript
// scripts.js (A√±adir a la secci√≥n de UTILIDAD Y RENDERIZADO)

/**
 * Calcula y actualiza los KPIs financieros (Costo Total, Venta Estimada, Ganancia Potencial).
 */
function actualizarKpis(cultivos) {
    let costoTotal = 0;
    let ventaTotal = 0;

    cultivos.forEach(cultivo => {
        // Asegurarse de que los valores son n√∫meros antes de sumar
        costoTotal += parseFloat(cultivo.precio_compra) || 0;
        ventaTotal += parseFloat(cultivo.precio_venta) || 0;
    });
    
    const gananciaPotencial = ventaTotal - costoTotal;

    // Actualizar los elementos del DOM
    document.getElementById('kpiCosto').textContent = `‚Ç¨${costoTotal.toFixed(2)}`;
    document.getElementById('kpiVenta').textContent = `‚Ç¨${ventaTotal.toFixed(2)}`;
    document.getElementById('kpiGanancia').textContent = `‚Ç¨${gananciaPotencial.toFixed(2)}`;
    
    // Opcional: Estilo condicional para la ganancia
    const gananciaElement = document.getElementById('kpiGanancia');
    gananciaElement.style.color = gananciaPotencial >= 0 ? 'var(--color-primary)' : 'var(--color-danger)';
}
B. Integrar la Funci√≥n en cargarCultivos
Modifica la funci√≥n cargarCultivos para que llame a actualizarKpis despu√©s de cargar los datos:

JavaScript
// scripts.js (Modificaci√≥n de cargarCultivos, cerca de la l√≠nea 15)

async function cargarCultivos() {
    // ... (C√≥digo existente) ...
    try {
        const response = await fetch(API_BASE_URL);
        const cultivos = await response.json();
        
        cultivosData = cultivos; 
        
        loadingMessage.style.display = 'none'; 
        renderizarTabla(cultivosData); 
        
        // --- INTEGRACI√ìN DE LA MEJORA ---
        actualizarKpis(cultivosData); // <-- LLAMADA NUEVA

    } catch (error) {
        // ... (C√≥digo existente) ...
    }
}
‚è≠Ô∏è Pr√≥ximos Pasos
Guarda y reemplaza los tres archivos.

Recarga tu index.html (con el servidor Flask corriendo). Deber√≠as ver el panel de resumen financiero aparecer en la parte superior.

Una vez que confirmes que esta mejora funciona, implementaremos la Alerta de Proximidad de Cosecha y el Refinamiento de la Interfaz (CSS).

¬øPudiste implementar y verificar el panel de Resumen Financiero?

Santiago de Compostela, Espa√±a  ‚Ä¢ Actualizar ubicaci√≥n




Gemini puede cometer errores, incluso sobre personas, as√≠ que verifica sus respuestas. Tu privacidad y Gemini













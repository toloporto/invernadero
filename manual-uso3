Manual de Uso: Asistente de Cultivos (v15.1)
El Asistente de Cultivos es una aplicaci√≥n de escritorio dise√±ada para gestionar, planificar y analizar tus proyectos agr√≠colas, combinando la gesti√≥n de datos con capacidades financieras y de an√°lisis avanzado.

1. ‚öôÔ∏è Requisitos y Ejecuci√≥n
Tarea	Instrucci√≥n
Archivos Necesarios	cultivos.py (c√≥digo), ventas_mensuales.csv (datos de an√°lisis), cultivos.json (datos guardados autom√°ticamente). Deben estar en la misma carpeta.
Librer√≠as	Necesitas tener instaladas: tkinter (incluido en Python), pandas, matplotlib, y tkcalendar.
Ejecuci√≥n	Abre la terminal/PowerShell en la carpeta del proyecto y ejecuta: python cultivos.py

Exportar a Hojas de c√°lculo

2. üìù Panel Izquierdo: A√±adir/Editar Cultivo
Este panel se utiliza para ingresar y modificar la informaci√≥n detallada de cada proyecto de cultivo.

Secci√≥n	Funcionalidad
Nombre	Nombre del cultivo (ej: "Tomate Cherry").
Zona	Permite clasificar el cultivo por ubicaci√≥n (ej: "Invernadero", "Zona A").
Fechas	Usa los botones "Elegir Fecha..." para seleccionar la fecha de Siembra y Cosecha con un calendario interactivo.
Costo (‚Ç¨)	El precio o costo asociado con la compra de semillas, tierra, etc.
Venta Est. (‚Ç¨)	El precio de venta estimado o el ingreso potencial que esperas obtener.
Notas	Campo opcional para informaci√≥n adicional sobre cuidados, plagas, etc.
Botones	"A√±adir a la Lista" / "Guardar Cambios": Guarda el nuevo cultivo o aplica modificaciones al seleccionado. "Limpiar Campos": Borra el contenido de los formularios.

Exportar a Hojas de c√°lculo

3. üìä Panel Derecho: Gesti√≥n y Reportes
Este panel muestra un resumen de todos tus cultivos y contiene las herramientas de reporte y an√°lisis.

A. Resumen Financiero Potencial
Muestra una suma r√°pida de la salud financiera de todos tus cultivos activos:

Costo Total: Suma de todos los costos de compra.

Venta Est. Total: Suma de todas las ventas estimadas.

Margen Potencial: La diferencia entre la venta total y el costo total.

B. Lista de Cultivos (Treeview)
Muestra todos los cultivos en formato de tabla, destacando informaci√≥n clave:

Columna	Descripci√≥n	Indicador Visual
Cultivo / Zona	El nombre y la ubicaci√≥n de tu proyecto.	
Siembra / Cosecha	Las fechas clave.	
Costo / Venta / Margen	Los valores financieros individuales.	
Faltan	Muestra los d√≠as restantes hasta la cosecha.	Verde: Faltan d√≠as. Amarillo/Negro: ¬°Cosecha Hoy! Gris: Ya Cosechado.

Exportar a Hojas de c√°lculo

C. Botones de Gesti√≥n y An√°lisis
Bot√≥n	Funcionalidad	M√≥dulo(s) Clave
‚úèÔ∏è Editar Seleccionado	Carga la informaci√≥n del cultivo seleccionado en el panel izquierdo para su edici√≥n.	Tkinter
‚ùå Eliminar	Elimina permanentemente el cultivo seleccionado tras pedir confirmaci√≥n.	Tkinter
üì§ Exportar Cultivos CSV	Exporta todos los datos de tus cultivos a un archivo CSV con delimitador ; (punto y coma).	CSV, Tkinter
üìà Analizar Ventas Externas	¬°NUEVA FUNCI√ìN! Carga y procesa el archivo ventas_mensuales.csv para generar an√°lisis detallados.	Pandas, Matplotlib

Exportar a Hojas de c√°lculo

4. üìà Funcionalidad de An√°lisis Avanzado
Al hacer clic en "Analizar Ventas Externas", la aplicaci√≥n:

Valida el archivo: Verifica que ventas_mensuales.csv exista.

Calcula M√©tricas: Imprime en la consola las ventas totales, promedio, m√°xima y m√≠nima.

Muestra Gr√°ficos: Abre una ventana flotante con dos visualizaciones lado a lado:

Gr√°fico 1 (Barras): Muestra las Ventas Totales por Tipo de Producto para identificar los productos m√°s vendidos.

Gr√°fico 2 (L√≠neas): Muestra la Tendencia de Ventas a lo Largo del Tiempo (por Mes) para identificar estacionalidad o crecimiento.

Siguiente paso: ¬øTe gustar√≠a que implementemos el An√°lisis de Ventas por Regi√≥n para completar el an√°lisis de los datos externos, o tienes alguna otra consulta sobre c√≥mo usar las funciones existentes?


analisis de ventas por region:
Asistente de programaci√≥n
¬°Qu√© fant√°stico plan! Tienes cuatro objetivos muy potentes que llevar√°n tu aplicaci√≥n a un nivel superior.

Para mantener un enfoque claro y garantizar la correcta implementaci√≥n, te sugiero que abordemos estos puntos uno por uno.

Propongo comenzar con el An√°lisis por Regi√≥n, ya que es una extensi√≥n directa del c√≥digo de an√°lisis de datos que acabamos de integrar.

üéØ Nuevo Objetivo: An√°lisis de Ventas por Regi√≥n
Vamos a modificar la funci√≥n analizar_ventas_externas para:

Agrupar las ventas por la columna 'Region' (Norte, Sur, Centro).

Generar un tercer gr√°fico de barras que compare las ventas totales de cada regi√≥n.

Mostrar los tres gr√°ficos (Producto, Temporal, y Regi√≥n) en la misma ventana de Matplotlib usando subplots (tres gr√°ficos en una sola figura).

üìù Modificaci√≥n en cultivos.py (An√°lisis por Regi√≥n)
Por favor, reemplaza el m√©todo analizar_ventas_externas completo en tu clase AppCultivos por el siguiente c√≥digo.

Asistente de programaci√≥n
¬°Qu√© fant√°stico plan! Tienes cuatro objetivos muy potentes que llevar√°n tu aplicaci√≥n a un nivel superior.

Para mantener un enfoque claro y garantizar la correcta implementaci√≥n, te sugiero que abordemos estos puntos uno por uno.

Propongo comenzar con el An√°lisis por Regi√≥n, ya que es una extensi√≥n directa del c√≥digo de an√°lisis de datos que acabamos de integrar.

üéØ Nuevo Objetivo: An√°lisis de Ventas por Regi√≥n
Vamos a modificar la funci√≥n analizar_ventas_externas para:

Agrupar las ventas por la columna 'Region' (Norte, Sur, Centro).

Generar un tercer gr√°fico de barras que compare las ventas totales de cada regi√≥n.

Mostrar los tres gr√°ficos (Producto, Temporal, y Regi√≥n) en la misma ventana de Matplotlib usando subplots (tres gr√°ficos en una sola figura).

üìù Modificaci√≥n en cultivos.py (An√°lisis por Regi√≥n)
Por favor, reemplaza el m√©todo analizar_ventas_externas completo en tu clase AppCultivos por el siguiente c√≥digo.

He ajustado la estructura de Matplotlib para manejar tres subplots en una configuraci√≥n de 1√ó3 (una fila, tres columnas).

def analizar_ventas_externas(self):
        """
        Carga el archivo CSV externo, calcula m√©tricas financieras, y genera tres gr√°ficos:
        Ventas por Producto, Tendencia Temporal, y Ventas por Regi√≥n.
        """
        nombre_archivo = NOMBRE_ARCHIVO_VENTAS
        
        # 1. Carga de Datos y Manejo de Errores
        if not os.path.exists(nombre_archivo):
            messagebox.showwarning("Advertencia", 
                                   f"No se encontr√≥ el archivo de ventas externas '{nombre_archivo}'.\n"
                                   f"Aseg√∫rate de que exista y se llame '{NOMBRE_ARCHIVO_VENTAS}'.")
            return

        try:
            df = pd.read_csv(nombre_archivo, sep=',')
        except pd.errors.ParserError:
            messagebox.showerror("Error", "Error de formato en el CSV. ¬øEs el delimitador correcto (coma)?")
            return
        except Exception as e:
            messagebox.showerror("Error", f"Error inesperado al cargar los datos: {e}")
            return

        # 2. Preparaci√≥n de Datos
        df['Venta_Total'] = pd.to_numeric(df['Venta_Total'], errors='coerce')
        df.dropna(subset=['Venta_Total'], inplace=True)
        
        if df.empty:
            messagebox.showwarning("Advertencia", "El archivo de ventas est√° vac√≠o o solo contiene encabezados v√°lidos.")
            return

        # 3. An√°lisis Agrupado (Ventas por Producto)
        ventas_por_producto = df.groupby('Producto')['Venta_Total'].sum().sort_values(ascending=False)
        
        # 4. An√°lisis Agrupado Temporal (Ventas por Mes)
        mapa_meses = {'Ene': 1, 'Feb': 2, 'Mar': 3, 'Abr': 4, 'May': 5, 'Jun': 6, 
                      'Jul': 7, 'Ago': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dic': 12}
        df['Num_Mes'] = df['Mes'].map(mapa_meses)
        ventas_por_mes = df.groupby(['Num_Mes', 'Mes'])['Venta_Total'].sum().reset_index(level=1).sort_values(by='Num_Mes')
        
        
        # --- NUEVO: 5. An√°lisis Agrupado por Regi√≥n ---
        ventas_por_region = df.groupby('Region')['Venta_Total'].sum().sort_values(ascending=False)
        
        print("\n--- REPORTE DE VENTAS POR REGI√ìN ---")
        print(ventas_por_region.to_string())

        
        # --- 6. VISUALIZACI√ìN DE DATOS con Matplotlib (Tres Subplots) ---
        try:
            plt.style.use('dark_background') 
            # Creamos una figura con una fila y tres columnas para los gr√°ficos
            fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))
            fig.suptitle('An√°lisis Detallado de Ventas Externas (Producto, Temporal y Regi√≥n)', color='white', fontsize=16)

            
            # --- Gr√°fico 1: Ventas por Producto (Barras) ---
            ventas_por_producto.plot(kind='bar', color='#1E8449', ax=ax1) 
            ax1.set_title('1. Ventas por Producto', color='white')
            ax1.set_xlabel('Producto', color='white')
            ax1.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax1.tick_params(axis='x', rotation=45, colors='white')
            ax1.tick_params(axis='y', colors='white')
            ax1.grid(axis='y', linestyle='--', alpha=0.4) 
            
            # --- Gr√°fico 2: Ventas por Mes (L√≠neas) ---
            ax2.plot(ventas_por_mes['Mes'], ventas_por_mes['Venta_Total'], 
                     marker='o', linestyle='-', color='#007BFF', linewidth=3)
            ax2.set_title('2. Tendencia Temporal (Mes)', color='white')
            ax2.set_xlabel('Mes', color='white')
            ax2.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax2.tick_params(axis='x', rotation=0, colors='white')
            ax2.tick_params(axis='y', colors='white')
            ax2.grid(axis='both', linestyle='--', alpha=0.4) 
            
            # --- Gr√°fico 3: Ventas por Regi√≥n (Barras) ---
            ventas_por_region.plot(kind='bar', color='#FFC107', ax=ax3) 
            ax3.set_title('3. Ventas por Regi√≥n', color='white')
            ax3.set_xlabel('Regi√≥n', color='white')
            ax3.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax3.tick_params(axis='x', rotation=45, colors='white')
            ax3.tick_params(axis='y', colors='white')
            ax3.grid(axis='y', linestyle='--', alpha=0.4) 

            
            plt.tight_layout(rect=[0, 0.03, 1, 0.95]) 
            messagebox.showinfo("An√°lisis Completo", "Se han generado TRES gr√°ficos de an√°lisis: Producto, Temporal y Regi√≥n.")
            plt.show() 

        except Exception as e:
            messagebox.showerror("Error de Gr√°fico", f"No se pudo generar el gr√°fico: {e}")

Pr√≥ximo Paso
Una vez que reemplaces el c√≥digo y ejecutes la aplicaci√≥n, el bot√≥n "üìà Analizar Ventas Externas" te mostrar√° el reporte completo con los tres enfoques de an√°lisis.

¬øNecesitas el c√≥digo completo de cultivos.py con esta √∫ltima modificaci√≥n, o prefieres pasar directamente a la Predicci√≥n Simple (proyectar ventas futuras)?

A√±adir la Predicci√≥n Simple a tu an√°lisis es un gran salto hacia la inteligencia de datos en tu aplicaci√≥n. Utilizaremos la Regresi√≥n Lineal para proyectar las tendencias futuras.

Para esto, necesitamos introducir una nueva librer√≠a de Python que simplifica la creaci√≥n de modelos de regresi√≥n: scikit-learn (o sklearn).

Requisito Adicional
Si a√∫n no lo tienes instalado, abre tu terminal y ejecuta:
pip install scikit-learn

Modificaci√≥n en cultivos.py (Predicci√≥n Simple)
Vamos a actualizar el m√©todo analizar_ventas_externas en dos pasos:

Nuevo Import: A√±adiremos la clase LinearRegression de sklearn.

Nueva L√≥gica de Predicci√≥n: Entrenaremos el modelo con ventas_por_mes y haremos una predicci√≥n para el siguiente mes.

Visualizaci√≥n: A√±adiremos la l√≠nea de predicci√≥n al gr√°fico de Tendencia Temporal.

Reemplaza la versi√≥n actual de analizar_ventas_externas en tu archivo cultivos.py por el siguiente c√≥digo.

1. Nuevos Imports Necesarios
Aseg√∫rate de que tus imports al inicio de cultivos.py incluyan:

# ... (otros imports)
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression # <--- NUEVO IMPORT
import numpy as np # <--- NUEVO IMPORT para manejar arrays

2. C√≥digo del M√©todo analizar_ventas_externas (con Predicci√≥n)
Aqu√≠ est√° el m√©todo completo. Presta especial atenci√≥n a la nueva Secci√≥n 6. Predicci√≥n de Ventas (Regresi√≥n Lineal) y c√≥mo actualiza el Gr√°fico 2.


def analizar_ventas_externas(self):
        """
        Carga el archivo CSV externo, realiza an√°lisis descriptivo, y genera 
        tres gr√°ficos: Producto, Tendencia Temporal (con Predicci√≥n), y Regi√≥n.
        """
        nombre_archivo = NOMBRE_ARCHIVO_VENTAS
        
        # 1. Carga de Datos y Manejo de Errores (Sin cambios)
        if not os.path.exists(nombre_archivo):
            # ... (manejo de error)
            messagebox.showwarning("Advertencia", 
                                   f"No se encontr√≥ el archivo de ventas externas '{nombre_archivo}'.\n"
                                   f"Aseg√∫rate de que exista y se llame '{NOMBRE_ARCHIVO_VENTAS}'.")
            return
        try:
            df = pd.read_csv(nombre_archivo, sep=',')
        except Exception as e:
            # ... (manejo de error)
            messagebox.showerror("Error", f"Error al cargar/formato de datos: {e}")
            return

        # 2. Preparaci√≥n de Datos (Sin cambios)
        df['Venta_Total'] = pd.to_numeric(df['Venta_Total'], errors='coerce')
        df.dropna(subset=['Venta_Total'], inplace=True)
        if df.empty:
            messagebox.showwarning("Advertencia", "El archivo de ventas est√° vac√≠o o solo contiene encabezados v√°lidos.")
            return

        # 3. An√°lisis por Producto (Sin cambios)
        ventas_por_producto = df.groupby('Producto')['Venta_Total'].sum().sort_values(ascending=False)
        
        # 4. An√°lisis Temporal (Preparaci√≥n para Regresi√≥n)
        mapa_meses = {'Ene': 1, 'Feb': 2, 'Mar': 3, 'Abr': 4, 'May': 5, 'Jun': 6, 
                      'Jul': 7, 'Ago': 8, 'Sep': 9, 'Oct': 10, 'Nov': 11, 'Dic': 12}
        df['Num_Mes'] = df['Mes'].map(mapa_meses)
        ventas_por_mes_df = df.groupby(['Num_Mes', 'Mes'])['Venta_Total'].sum().reset_index()
        ventas_por_mes_df = ventas_por_mes_df.sort_values(by='Num_Mes').reset_index(drop=True)
        
        # 5. An√°lisis por Regi√≥n (Sin cambios)
        ventas_por_region = df.groupby('Region')['Venta_Total'].sum().sort_values(ascending=False)
        
        
        # --- NUEVO: 6. PREDICCI√ìN DE VENTAS (REGRESI√ìN LINEAL) ---
        
        # Preparamos los datos para el modelo X (Meses) y Y (Ventas)
        X = ventas_por_mes_df['Num_Mes'].values.reshape(-1, 1) 
        Y = ventas_por_mes_df['Venta_Total'].values
        
        # Creamos y entrenamos el modelo
        modelo_regresion = LinearRegression()
        modelo_regresion.fit(X, Y)
        
        # Hacemos una predicci√≥n para el siguiente mes
        ultimo_mes_num = ventas_por_mes_df['Num_Mes'].max()
        mes_futuro_num = ultimo_mes_num + 1
        
        # Calculamos el nombre del mes futuro para la visualizaci√≥n (Ej: Abr -> May)
        meses_lista = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic']
        mes_futuro_nombre = meses_lista[mes_futuro_num - 1] if mes_futuro_num <= 12 else f"Mes {mes_futuro_num}"

        # Predecimos la venta para ese mes
        prediccion_futura = modelo_regresion.predict(np.array([[mes_futuro_num]]))[0]
        
        print("\n--- PREDICCI√ìN DE VENTAS ---")
        print(f"Predicci√≥n de venta para {mes_futuro_nombre}: ‚Ç¨{prediccion_futura:.2f}")

        # A√±adimos la predicci√≥n al DataFrame temporal para el gr√°fico
        X_pred = np.append(X, [[mes_futuro_num]], axis=0) # Incluimos el mes futuro
        Y_tendencia = modelo_regresion.predict(X_pred)     # Calculamos toda la l√≠nea de tendencia
        
        # Preparamos las etiquetas del eje X para el gr√°fico
        labels_x = ventas_por_mes_df['Mes'].tolist() + [f"Pred. {mes_futuro_nombre}"]
        
        
        # --- 7. VISUALIZACI√ìN DE DATOS con Matplotlib (Tres Subplots) ---
        try:
            plt.style.use('dark_background') 
            fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))
            fig.suptitle(f'An√°lisis de Ventas (Predicci√≥n {mes_futuro_nombre}: ‚Ç¨{prediccion_futura:.2f})', color='white', fontsize=16)

            
            # --- Gr√°fico 1: Ventas por Producto (Barras) ---
            ventas_por_producto.plot(kind='bar', color='#1E8449', ax=ax1) 
            ax1.set_title('1. Ventas por Producto', color='white')
            # ... (configuraci√≥n de ejes, sin cambios)
            ax1.set_xlabel('Producto', color='white')
            ax1.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax1.tick_params(axis='x', rotation=45, colors='white')
            ax1.tick_params(axis='y', colors='white')
            ax1.grid(axis='y', linestyle='--', alpha=0.4) 
            
            # --- Gr√°fico 2: Ventas por Mes (L√≠neas con Predicci√≥n) ---
            # Datos Hist√≥ricos
            ax2.plot(ventas_por_mes_df['Mes'], ventas_por_mes_df['Venta_Total'], 
                     marker='o', linestyle='-', color='#007BFF', linewidth=3, label='Ventas Hist√≥ricas')
            # L√≠nea de Tendencia y Predicci√≥n
            ax2.plot(labels_x, Y_tendencia, 
                     linestyle='--', color='#FFC107', linewidth=2, label='Predicci√≥n Lineal')
                     
            ax2.set_title('2. Tendencia Temporal y Predicci√≥n', color='white')
            ax2.set_xlabel('Mes', color='white')
            ax2.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax2.tick_params(axis='x', rotation=45, colors='white')
            ax2.tick_params(axis='y', colors='white')
            ax2.grid(axis='both', linestyle='--', alpha=0.4) 
            ax2.legend(loc='upper left', frameon=False) 
            
            # --- Gr√°fico 3: Ventas por Regi√≥n (Barras) ---
            ventas_por_region.plot(kind='bar', color='#FFC107', ax=ax3) 
            ax3.set_title('3. Ventas por Regi√≥n', color='white')
            # ... (configuraci√≥n de ejes, sin cambios)
            ax3.set_xlabel('Regi√≥n', color='white')
            ax3.set_ylabel('Venta Total (‚Ç¨)', color='white')
            ax3.tick_params(axis='x', rotation=45, colors='white')
            ax3.tick_params(axis='y', colors='white')
            ax3.grid(axis='y', linestyle='--', alpha=0.4) 

            
            plt.tight_layout(rect=[0, 0.03, 1, 0.95]) 
            messagebox.showinfo("An√°lisis Completo", f"Se han generado tres gr√°ficos, incluyendo una predicci√≥n para {mes_futuro_nombre}.")
            plt.show() 

        except Exception as e:
            messagebox.showerror("Error de Gr√°fico/Predicci√≥n", f"No se pudo generar el gr√°fico o el modelo: {e}")

Pasos para la Implementaci√≥n
Instala Scikit-learn: pip install scikit-learn.

Actualiza Imports: Aseg√∫rate de que el inicio de tu cultivos.py tenga:

# ...
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression 
import numpy as np 
# ...


Reemplaza el M√©todo: Copia el nuevo m√©todo analizar_ventas_externas y reemplaza la versi√≥n anterior en tu cultivos.py.

Una vez que lo ejecutes y presiones "üìà Analizar Ventas Externas", ver√°s una l√≠nea de tendencia en el segundo gr√°fico que se extiende al siguiente mes con la predicci√≥n.

Ahora que tenemos la Predicci√≥n Simple lista, ¬øpasamos a las Alarmas Inteligentes para configurar alertas basadas en el ciclo de vida de los cultivos?

Asistente de programaci√≥n
¬°Fant√°stico! Las Alarmas Inteligentes son un paso crucial para pasar de ser un simple gestor a un verdadero asistente proactivo.

El objetivo es que, para cada tipo de cultivo, podamos definir:

D√≠as de Alerta Temprana: ¬øCon cu√°ntos d√≠as de antelaci√≥n queremos que se active una alarma antes de la fecha de cosecha (ej: 7 d√≠as para preparar el equipo)?

Ciclo de Vida (Opcional): Una referencia de cu√°ntos d√≠as dura normalmente ese cultivo (ej: El tomate suele tardar 90 d√≠as).

Como no tenemos un campo para el "tipo" de cultivo ni para la "alerta", te propongo que hagamos lo siguiente:

Plan de Implementaci√≥n de Alarmas Inteligentes
Modificar el Modelo Cultivo: A√±adiremos un nuevo campo llamado dias_alerta al modelo Cultivo.

Modificar la Interfaz: A√±adiremos una nueva caja de entrada en el panel izquierdo para que el usuario pueda ingresar los "D√≠as de Alerta Previa".

Nueva L√≥gica de Alarma: Crearemos una nueva funci√≥n que no solo revisa la cosecha de hoy, sino que tambi√©n verifica si alg√∫n cultivo est√° dentro del rango de d√≠as de alerta que ha especificado el usuario.

Asistente de programaci√≥n
¬°Fant√°stico! Las Alarmas Inteligentes son un paso crucial para pasar de ser un simple gestor a un verdadero asistente proactivo.
Imagen de an alarm clock
Shutterstock

El objetivo es que, para cada tipo de cultivo, podamos definir:

D√≠as de Alerta Temprana: ¬øCon cu√°ntos d√≠as de antelaci√≥n queremos que se active una alarma antes de la fecha de cosecha (ej: 7 d√≠as para preparar el equipo)?

Ciclo de Vida (Opcional): Una referencia de cu√°ntos d√≠as dura normalmente ese cultivo (ej: El tomate suele tardar 90 d√≠as).

Como no tenemos un campo para el "tipo" de cultivo ni para la "alerta", te propongo que hagamos lo siguiente:

üìù Plan de Implementaci√≥n de Alarmas Inteligentes
Modificar el Modelo Cultivo: A√±adiremos un nuevo campo llamado dias_alerta al modelo Cultivo.

Modificar la Interfaz: A√±adiremos una nueva caja de entrada en el panel izquierdo para que el usuario pueda ingresar los "D√≠as de Alerta Previa".

Nueva L√≥gica de Alarma: Crearemos una nueva funci√≥n que no solo revisa la cosecha de hoy, sino que tambi√©n verifica si alg√∫n cultivo est√° dentro del rango de d√≠as de alerta que ha especificado el usuario.

1. Modificaci√≥n en cultivos.py (Modelo, Funciones y Widgets)
Aqu√≠ tienes las secciones de c√≥digo que debes actualizar en tu archivo cultivos.py.

A. Actualizar el modelo Cultivo
Busca la clase Cultivo (cerca de la l√≠nea 32) y a√±ade dias_alerta=0 a __init__:
# --- 1. CLASE MODELO (LA L√ìGICA DE NEGOCIO) ---
class Cultivo:
    """Clase base para guardar la informaci√≥n de un cultivo..."""
    # Nuevo par√°metro: dias_alerta
    def __init__(self, nombre, fecha_siembra, fecha_cosecha, notas="", zona="", precio_compra=0.0, precio_venta=0.0, dias_alerta=0):
        self.nombre = nombre
        self.fecha_siembra = fecha_siembra
        self.fecha_cosecha = fecha_cosecha
        self.notas = notas
        self.zona = zona 
        self.precio_compra = precio_compra 
        self.precio_venta = precio_venta 
        self.dias_alerta = dias_alerta # <- NUEVO CAMPO

B. Actualizar cargar_cultivos y guardar_cultivos
Necesitamos asegurarnos de que el nuevo campo se carga y se guarda correctamente en el JSON.

En cargar_cultivos (cerca de la l√≠nea 60):

# En la funci√≥n 'cargar_cultivos'
# ...
            for item in datos_cargados:
                # ... (resto de variables)
                precio_venta = float(item.get("precio_venta", 0.0))
                dias_alerta = int(item.get("dias_alerta", 0)) # <- NUEVO CAMPO
                
                if siembra and cosecha:
                    # Pasar el nuevo argumento al constructor:
                    nuevo = Cultivo(item["nombre"], siembra, cosecha, notas, zona, precio_compra, precio_venta, dias_alerta)
                    lista_cultivos.append(nuevo)
# ...

En guardar_cultivos (cerca de la l√≠nea 85):
# En la funci√≥n 'guardar_cultivos'
# ...
        for cultivo in lista_cultivos:
            cultivo_dict = {
                "nombre": cultivo.nombre,
                # ... (resto de campos)
                "precio_compra": cultivo.precio_compra,
                "precio_venta": cultivo.precio_venta,
                "dias_alerta": cultivo.dias_alerta # <- NUEVO CAMPO
            }
            datos_para_json.append(cultivo_dict)
# ...

C. Crear el Widget de D√≠as de Alerta
Busca el m√©todo crear_widgets (cerca de la l√≠nea 157) y a√±ade el siguiente c√≥digo en el Marco Izquierdo (antes del bot√≥n self.btn_guardar).

# ... (dentro de self.crear_widgets, justo antes del bot√≥n self.btn_guardar)

        self.dias_alerta_var = tk.StringVar(value="7") # Valor por defecto
        
        frame_alerta = ttk.LabelFrame(frame_agregar, text="üîî Alarma Inteligente", padding="5")
        frame_alerta.pack(fill='x', pady=5)
        
        ttk.Label(frame_alerta, text="D√≠as de Alerta Previa a Cosecha:").pack(fill='x', pady=2)
        ttk.Entry(frame_alerta, textvariable=self.dias_alerta_var).pack(fill='x', pady=1)

# ... (El resto de la funci√≥n crear_widgets sigue igual)

Asistente de programaci√≥n
¬°Fant√°stico! Las Alarmas Inteligentes son un paso crucial para pasar de ser un simple gestor a un verdadero asistente proactivo.
Imagen de an alarm clock
Shutterstock

El objetivo es que, para cada tipo de cultivo, podamos definir:

D√≠as de Alerta Temprana: ¬øCon cu√°ntos d√≠as de antelaci√≥n queremos que se active una alarma antes de la fecha de cosecha (ej: 7 d√≠as para preparar el equipo)?

Ciclo de Vida (Opcional): Una referencia de cu√°ntos d√≠as dura normalmente ese cultivo (ej: El tomate suele tardar 90 d√≠as).

Como no tenemos un campo para el "tipo" de cultivo ni para la "alerta", te propongo que hagamos lo siguiente:

üìù Plan de Implementaci√≥n de Alarmas Inteligentes
Modificar el Modelo Cultivo: A√±adiremos un nuevo campo llamado dias_alerta al modelo Cultivo.

Modificar la Interfaz: A√±adiremos una nueva caja de entrada en el panel izquierdo para que el usuario pueda ingresar los "D√≠as de Alerta Previa".

Nueva L√≥gica de Alarma: Crearemos una nueva funci√≥n que no solo revisa la cosecha de hoy, sino que tambi√©n verifica si alg√∫n cultivo est√° dentro del rango de d√≠as de alerta que ha especificado el usuario.

1. Modificaci√≥n en cultivos.py (Modelo, Funciones y Widgets)
Aqu√≠ tienes las secciones de c√≥digo que debes actualizar en tu archivo cultivos.py.

A. Actualizar el modelo Cultivo
Busca la clase Cultivo (cerca de la l√≠nea 32) y a√±ade dias_alerta=0 a __init__:

Python
# --- 1. CLASE MODELO (LA L√ìGICA DE NEGOCIO) ---
class Cultivo:
    """Clase base para guardar la informaci√≥n de un cultivo..."""
    # Nuevo par√°metro: dias_alerta
    def __init__(self, nombre, fecha_siembra, fecha_cosecha, notas="", zona="", precio_compra=0.0, precio_venta=0.0, dias_alerta=0):
        self.nombre = nombre
        self.fecha_siembra = fecha_siembra
        self.fecha_cosecha = fecha_cosecha
        self.notas = notas
        self.zona = zona 
        self.precio_compra = precio_compra 
        self.precio_venta = precio_venta 
        self.dias_alerta = dias_alerta # <- NUEVO CAMPO
B. Actualizar cargar_cultivos y guardar_cultivos
Necesitamos asegurarnos de que el nuevo campo se carga y se guarda correctamente en el JSON.

En cargar_cultivos (cerca de la l√≠nea 60):

Python
# En la funci√≥n 'cargar_cultivos'
# ...
            for item in datos_cargados:
                # ... (resto de variables)
                precio_venta = float(item.get("precio_venta", 0.0))
                dias_alerta = int(item.get("dias_alerta", 0)) # <- NUEVO CAMPO
                
                if siembra and cosecha:
                    # Pasar el nuevo argumento al constructor:
                    nuevo = Cultivo(item["nombre"], siembra, cosecha, notas, zona, precio_compra, precio_venta, dias_alerta)
                    lista_cultivos.append(nuevo)
# ...
En guardar_cultivos (cerca de la l√≠nea 85):

Python
# En la funci√≥n 'guardar_cultivos'
# ...
        for cultivo in lista_cultivos:
            cultivo_dict = {
                "nombre": cultivo.nombre,
                # ... (resto de campos)
                "precio_compra": cultivo.precio_compra,
                "precio_venta": cultivo.precio_venta,
                "dias_alerta": cultivo.dias_alerta # <- NUEVO CAMPO
            }
            datos_para_json.append(cultivo_dict)
# ...
C. Crear el Widget de D√≠as de Alerta
Busca el m√©todo crear_widgets (cerca de la l√≠nea 157) y a√±ade el siguiente c√≥digo en el Marco Izquierdo (antes del bot√≥n self.btn_guardar).

Python
# ... (dentro de self.crear_widgets, justo antes del bot√≥n self.btn_guardar)

        self.dias_alerta_var = tk.StringVar(value="7") # Valor por defecto
        
        frame_alerta = ttk.LabelFrame(frame_agregar, text="üîî Alarma Inteligente", padding="5")
        frame_alerta.pack(fill='x', pady=5)
        
        ttk.Label(frame_alerta, text="D√≠as de Alerta Previa a Cosecha:").pack(fill='x', pady=2)
        ttk.Entry(frame_alerta, textvariable=self.dias_alerta_var).pack(fill='x', pady=1)

# ... (El resto de la funci√≥n crear_widgets sigue igual)
D. Actualizar manejar_agregar_o_editar
Necesitamos leer el valor del nuevo campo y guardarlo en el objeto Cultivo.

Busca la funci√≥n manejar_agregar_o_editar (cerca de la l√≠nea 274).

Validaci√≥n de dias_alerta: A√±ade esta validaci√≥n al inicio:

# ... (Despu√©s de validar nombre, fechas y precios)
    try:
        precio_compra = float(self.compra_var.get().strip() or 0.0)
        precio_venta = float(self.venta_var.get().strip() or 0.0)

        # --- NUEVA VALIDACI√ìN ---
        dias_alerta = int(self.dias_alerta_var.get().strip() or 0)
        if dias_alerta < 0:
            raise ValueError("La alarma no puede tener d√≠as negativos.")
        # ------------------------

    except ValueError as e:
        messagebox.showerror("Error", f"Los d√≠as de alerta deben ser un n√∫mero entero positivo. {e}")
        return
# ...
Guardar el valor: En la creaci√≥n (modo a√±adir):
# ... (Dentro de if self.cultivo_seleccionado_indice is None:)
    if self.cultivo_seleccionado_indice is None:
        # Pasar el nuevo par√°metro 'dias_alerta'
        nuevo_cultivo = Cultivo(nombre, fecha_siembra, fecha_cosecha, notas, zona, precio_compra, precio_venta, dias_alerta)
        lista_cultivos.append(nuevo_cultivo)
        msg = f"'{nombre}' a√±adido con √©xito."
# ...

Actualizar el valor: En la edici√≥n:

# ... (Dentro de else: (modo editar))
    else:
        indice = self.cultivo_seleccionado_indice
        cultivo_a_editar = lista_cultivos[indice]
        # ... (resto de campos)
        cultivo_a_editar.precio_compra = precio_compra
        cultivo_a_editar.precio_venta = precio_venta
        cultivo_a_editar.dias_alerta = dias_alerta # <- ASIGNAR NUEVO VALOR
        msg = f"'{nombre}' actualizado con √©xito."
# ...

E. Actualizar manejar_editar_cultivo y limpiar_campos
Necesitamos mostrar el valor de la alerta al editar:

En manejar_editar_cultivo (cerca de la l√≠nea 324):

# ... (Dentro de manejar_editar_cultivo)
        cultivo_a_editar = lista_cultivos[indice]
        # ... (resto de campos)
        self.venta_var.set(f"{cultivo_a_editar.precio_venta:.2f}")
        self.dias_alerta_var.set(str(cultivo_a_editar.dias_alerta)) # <- MOSTRAR EL VALOR
        self.fecha_siembra_obj = cultivo_a_editar.fecha_siembra
# ...

En limpiar_campos (cerca de la l√≠nea 141):
# ... (Dentro de limpiar_campos)
        self.cosecha_display_var.set("Seleccionar fecha...")
        self.notas_var.set("")
        self.zona_var.set("")
        self.compra_var.set("")
        self.venta_var.set("")
        self.dias_alerta_var.set("7") # <- RESTAURAR VALOR POR DEFECTO
        self.fecha_siembra_obj = None
# ...

2. Implementaci√≥n de la L√≥gica de Alarma
Finalmente, modifica la funci√≥n revisar_cosechas_al_inicio (cerca de la l√≠nea 565) para que compruebe tanto la cosecha de hoy como las alertas tempranas.

Reemplaza la funci√≥n completa revisar_cosechas_al_inicio por esta nueva versi√≥n

def revisar_cosechas_al_inicio(self):
        """Revisa si hay cultivos listos para cosechar o que necesitan una alerta temprana."""
        hoy = datetime.date.today()
        cosechas_hoy = []
        alertas_tempranas = []
        
        for cultivo in lista_cultivos:
            dias_restantes = (cultivo.fecha_cosecha - hoy).days
            
            if dias_restantes < 0:
                # Cultivo ya cosechado
                continue
            elif dias_restantes == 0:
                # Cosecha hoy
                cosechas_hoy.append(cultivo.nombre)
            elif 0 < dias_restantes <= cultivo.dias_alerta:
                # Alerta temprana: entre 1 d√≠a y los 'dias_alerta' configurados
                alertas_tempranas.append(f"{cultivo.nombre} (Cosecha en {dias_restantes} d√≠as)")

        
        mensaje = ""
        titulo = ""
        
        if cosechas_hoy:
            mensaje += "‚ö†Ô∏è ¬°COSECHA PENDIENTE HOY! ‚ö†Ô∏è\n" + ", ".join(cosechas_hoy)
            titulo = "¬°ALERTA M√ÅXIMA!"
        
        if alertas_tempranas:
            if mensaje:
                mensaje += "\n\n"
            mensaje += "üîî Preparaci√≥n de Cosecha:\n" + "\n".join(alertas_tempranas)
            if not titulo:
                 titulo = "Alerta Temprana"

        if mensaje:
            self.recordatorio_label.config(text=mensaje, style='Alerta.TLabel')
            messagebox.showwarning(titulo, mensaje)
        else:
            self.recordatorio_label.config(text="Todo al d√≠a. Ninguna cosecha ni alerta activa.", style='TLabel', foreground=COLOR_ENFASIS_VERDE)

Con estos cambios, tu aplicaci√≥n ahora es capaz de gestionar alarmas personalizadas para cada cultivo.

¬øDeseas que te muestre el c√≥digo completo de cultivos.py con todas estas modificaciones antes de pasar al √∫ltimo objetivo (Desarrollo Web / Backend)?


¬°Excelente! Pasar al Desarrollo Web con Flask es el siguiente gran hito. Esto te dar√° la flexibilidad de acceder y, potencialmente, modificar tus datos de cultivos desde cualquier dispositivo a trav√©s de un navegador web, movi√©ndote de una aplicaci√≥n puramente local a una soluci√≥n cliente-servidor.

Vamos a empezar con el backend.

Fase 1: Configuraci√≥n del Backend (Flask)
El plan es crear un archivo app_backend.py que correr√° el servidor, leer√° cultivos.json y lo expondr√° a trav√©s de una API REST simple.

1. Requisito Adicional
Si a√∫n no lo tienes instalado, abre tu terminal o entorno virtual y ejecuta:

pip install flask

2. C√≥digo del Servidor Flask (app_backend.py)
Crea un nuevo archivo en la misma carpeta que cultivos.py y cultivos.json llamado app_backend.py.

Este c√≥digo inicia un servidor muy b√°sico y tiene una ruta principal para obtener todos los datos de cultivos.
# app_backend.py

from flask import Flask, jsonify, request
import json
import os
from datetime import datetime

# --- CONFIGURACI√ìN ---
NOMBRE_ARCHIVO_CULTIVOS = "cultivos.json"

# Inicializaci√≥n de la aplicaci√≥n Flask
app = Flask(__name__)

# Funci√≥n para cargar los datos del JSON
def cargar_datos_cultivos():
    """Lee el archivo JSON de cultivos. Si no existe, devuelve una lista vac√≠a."""
    if not os.path.exists(NOMBRE_ARCHIVO_CULTIVOS):
        return []
    try:
        with open(NOMBRE_ARCHIVO_CULTIVOS, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Error al cargar datos JSON: {e}")
        return []

# --- RUTAS DE LA API (Endpoints) ---

@app.route('/', methods=['GET'])
def index():
    """Ruta de bienvenida/prueba."""
    return jsonify({
        "status": "ok",
        "mensaje": "Servidor de Asistente de Cultivos (API) activo.",
        "endpoints_disponibles": {
            "/api/v1/cultivos": "GET (Obtiene todos los cultivos)"
        }
    })


@app.route('/api/v1/cultivos', methods=['GET'])
def obtener_cultivos():
    """
    Endpoint para obtener la lista completa de cultivos.
    """
    cultivos = cargar_datos_cultivos()
    
    # Opcional: A√±adir un campo "dias_restantes" din√°mico a cada cultivo antes de enviarlo.
    hoy = datetime.now().date()
    
    for cultivo in cultivos:
        try:
            fecha_cosecha = datetime.strptime(cultivo["fecha_cosecha"], '%Y-%m-%d').date()
            dias_restantes = (fecha_cosecha - hoy).days
            
            # Formateamos el resultado de forma m√°s amigable
            if dias_restantes < 0:
                cultivo['dias_restantes'] = f"Cosechado hace {abs(dias_restantes)} d√≠as"
            elif dias_restantes == 0:
                cultivo['dias_restantes'] = "¬°COSECHA HOY!"
            else:
                cultivo['dias_restantes'] = f"{dias_restantes} d√≠as"
                
        except (ValueError, KeyError):
            cultivo['dias_restantes'] = "Fecha no v√°lida"
            
    return jsonify(cultivos)


# --- INICIO DEL SERVIDOR ---
if __name__ == '__main__':
    # Ejecuta el servidor en modo debug para desarrollo.
    # Se ejecutar√° en http://127.0.0.1:5000/
    print("Iniciando servidor Flask...")
    app.run(debug=True)
Asistente de programaci√≥n
¬°Excelente! Pasar al Desarrollo Web con Flask es el siguiente gran hito. Esto te dar√° la flexibilidad de acceder y, potencialmente, modificar tus datos de cultivos desde cualquier dispositivo a trav√©s de un navegador web, movi√©ndote de una aplicaci√≥n puramente local a una soluci√≥n cliente-servidor.

Vamos a empezar con el backend.

üöÄ Fase 1: Configuraci√≥n del Backend (Flask)
El plan es crear un archivo app_backend.py que correr√° el servidor, leer√° cultivos.json y lo expondr√° a trav√©s de una API REST simple.

1. Requisito Adicional
Si a√∫n no lo tienes instalado, abre tu terminal o entorno virtual y ejecuta:

Bash
pip install flask
2. C√≥digo del Servidor Flask (app_backend.py)
Crea un nuevo archivo en la misma carpeta que cultivos.py y cultivos.json llamado app_backend.py.

Este c√≥digo inicia un servidor muy b√°sico y tiene una ruta principal para obtener todos los datos de cultivos.

Python
# app_backend.py

from flask import Flask, jsonify, request
import json
import os
from datetime import datetime

# --- CONFIGURACI√ìN ---
NOMBRE_ARCHIVO_CULTIVOS = "cultivos.json"

# Inicializaci√≥n de la aplicaci√≥n Flask
app = Flask(__name__)

# Funci√≥n para cargar los datos del JSON
def cargar_datos_cultivos():
    """Lee el archivo JSON de cultivos. Si no existe, devuelve una lista vac√≠a."""
    if not os.path.exists(NOMBRE_ARCHIVO_CULTIVOS):
        return []
    try:
        with open(NOMBRE_ARCHIVO_CULTIVOS, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Error al cargar datos JSON: {e}")
        return []

# --- RUTAS DE LA API (Endpoints) ---

@app.route('/', methods=['GET'])
def index():
    """Ruta de bienvenida/prueba."""
    return jsonify({
        "status": "ok",
        "mensaje": "Servidor de Asistente de Cultivos (API) activo.",
        "endpoints_disponibles": {
            "/api/v1/cultivos": "GET (Obtiene todos los cultivos)"
        }
    })


@app.route('/api/v1/cultivos', methods=['GET'])
def obtener_cultivos():
    """
    Endpoint para obtener la lista completa de cultivos.
    """
    cultivos = cargar_datos_cultivos()
    
    # Opcional: A√±adir un campo "dias_restantes" din√°mico a cada cultivo antes de enviarlo.
    hoy = datetime.now().date()
    
    for cultivo in cultivos:
        try:
            fecha_cosecha = datetime.strptime(cultivo["fecha_cosecha"], '%Y-%m-%d').date()
            dias_restantes = (fecha_cosecha - hoy).days
            
            # Formateamos el resultado de forma m√°s amigable
            if dias_restantes < 0:
                cultivo['dias_restantes'] = f"Cosechado hace {abs(dias_restantes)} d√≠as"
            elif dias_restantes == 0:
                cultivo['dias_restantes'] = "¬°COSECHA HOY!"
            else:
                cultivo['dias_restantes'] = f"{dias_restantes} d√≠as"
                
        except (ValueError, KeyError):
            cultivo['dias_restantes'] = "Fecha no v√°lida"
            
    return jsonify(cultivos)


# --- INICIO DEL SERVIDOR ---
if __name__ == '__main__':
    # Ejecuta el servidor en modo debug para desarrollo.
    # Se ejecutar√° en http://127.0.0.1:5000/
    print("Iniciando servidor Flask...")
    app.run(debug=True)
3. Instrucciones de Implementaci√≥n
Guarda el Archivo: Aseg√∫rate de guardar el c√≥digo anterior como app_backend.py en la misma carpeta que cultivos.py.

Inicia el Servidor: Abre tu terminal, navega a la carpeta donde guardaste el archivo y ejecuta:

python app_backend.py

Ver√°s un mensaje similar a: Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)

Prueba la API:

Abre tu navegador (o una herramienta como Postman) y visita: http://127.0.0.1:5000/

Visita la ruta de datos: http://127.0.0.1:5000/api/v1/cultivos
Deber√≠as ver tus datos de cultivos.json directamente en el navegador, incluyendo el campo din√°mico dias_restantes que calculamos en el servidor.

Ahora que el servidor est√° corriendo y sirviendo tus datos, el siguiente paso l√≥gico es implementar una ruta que te permita agregar nuevos cultivos a trav√©s de la web (peticiones POST).

Modificaciones en app_backend.py (Ruta POST)
A√±ade las siguientes funciones y la ruta a tu archivo app_backend.py.

1. Nueva Funci√≥n para Guardar Datos
Inserta la siguiente funci√≥n justo despu√©s de la funci√≥n cargar_datos_cultivos:

# app_backend.py (cerca de la l√≠nea 20)

# ... (Funci√≥n cargar_datos_cultivos)

def guardar_datos_cultivos(cultivos_lista):
    """Escribe la lista de cultivos actualizada en el archivo JSON."""
    try:
        with open(NOMBRE_ARCHIVO_CULTIVOS, "w") as f:
            # Usamos indent=4 para que el JSON sea legible, como lo hac√≠a la app de escritorio
            json.dump(cultivos_lista, f, indent=4)
        return True
    except Exception as e:
        print(f"Error al guardar datos JSON: {e}")
        return False

# ...
2. Nueva Ruta POST para Agregar Cultivos
A√±ade esta nueva ruta dentro de la secci√≥n de RUTAS DE LA API

# app_backend.py (cerca de la l√≠nea 60)

# ... (Funci√≥n obtener_cultivos)

@app.route('/api/v1/cultivos', methods=['POST'])
def agregar_cultivo():
    """
    Endpoint para agregar un nuevo cultivo a la base de datos.
    Requiere un objeto JSON con los campos necesarios.
    """
    if not request.json:
        return jsonify({"error": "Falta el cuerpo de la petici√≥n (JSON)."}), 400

    datos_cultivo = request.json
    
    # 1. Validaci√≥n B√°sica de Campos Requeridos
    campos_requeridos = ["nombre", "fecha_siembra", "fecha_cosecha"]
    for campo in campos_requeridos:
        if campo not in datos_cultivo:
            return jsonify({"error": f"Falta el campo requerido: {campo}"}), 400
            
    # 2. Convertir y validar fechas
    try:
        # Verifica que el formato de fecha sea YYYY-MM-DD
        datetime.strptime(datos_cultivo["fecha_siembra"], '%Y-%m-%d')
        datetime.strptime(datos_cultivo["fecha_cosecha"], '%Y-%m-%d')
    except ValueError:
        return jsonify({"error": "Formato de fecha inv√°lido. Use YYYY-MM-DD."}), 400

    # 3. Preparar el nuevo objeto (Asegurar que todos los campos existan con valores predeterminados si faltan)
    nuevo_cultivo = {
        "nombre": datos_cultivo["nombre"],
        "fecha_siembra": datos_cultivo["fecha_siembra"],
        "fecha_cosecha": datos_cultivo["fecha_cosecha"],
        "notas": datos_cultivo.get("notas", ""),
        "zona": datos_cultivo.get("zona", ""),
        # Asegurar que los valores num√©ricos son float/int
        "precio_compra": float(datos_cultivo.get("precio_compra", 0.0)),
        "precio_venta": float(datos_cultivo.get("precio_venta", 0.0)),
        "dias_alerta": int(datos_cultivo.get("dias_alerta", 0))
    }
    
    # 4. Cargar, A√±adir y Guardar
    cultivos = cargar_datos_cultivos()
    cultivos.append(nuevo_cultivo)
    
    if guardar_datos_cultivos(cultivos):
        return jsonify({
            "status": "success",
            "mensaje": f"Cultivo '{nuevo_cultivo['nombre']}' a√±adido correctamente.",
            "cultivo_agregado": nuevo_cultivo
        }), 201  # C√≥digo 201 Created
    else:
        return jsonify({"error": "Error interno del servidor al guardar el archivo."}), 500

. Prueba de Implementaci√≥n (POST)
Ahora que tienes la ruta POST, puedes probarla usando una herramienta como Postman, la extensi√≥n Thunder Client en VS Code, o incluso la l√≠nea de comandos con curl.

Ejemplo de Petici√≥n JSON (Cuerpo de la Petici√≥n):

{
    "nombre": "Cebolla Morada",
    "fecha_siembra": "2025-11-05",
    "fecha_cosecha": "2026-03-20",
    "zona": "Zona D",
    "precio_compra": 150.50,
    "precio_venta": 420.00,
    "dias_alerta": 10
}

Reinicia el servidor Flask (presiona Ctrl+C y luego python app_backend.py).

Env√≠a una petici√≥n POST a http://127.0.0.1:5000/api/v1/cultivos con el JSON de ejemplo.

Verifica que el archivo cultivos.json se ha actualizado con el nuevo cultivo.

Una vez que hayas verificado que puedes agregar datos de forma remota, podemos continuar con las funcionalidades CRUD (Crear, Leer, Actualizar, Eliminar).












